/* tslint:disable */
/* eslint-disable */
/**
 * Dynamic API Specification
 * This is a dynamically generated API specification for all endpoints existing on the current project.
 *
 * The version of the OpenAPI document: 9.5.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base'

/**
 *
 * @export
 * @interface Activity
 */
export interface Activity {
  /**
   * Unique identifier for the object.
   * @type {number}
   * @memberof Activity
   */
  id?: number
  /**
   * Action that was performed.
   * @type {string}
   * @memberof Activity
   */
  action?: ActivityActionEnum
  /**
   * The user who performed this action.
   * @type {string | Users}
   * @memberof Activity
   */
  user?: string | Users | null
  /**
   * When the action happened.
   * @type {string}
   * @memberof Activity
   */
  timestamp?: string
  /**
   * The IP address of the user at the time the action took place.
   * @type {string}
   * @memberof Activity
   */
  ip?: string
  /**
   * User agent string of the browser the user used when the action took place.
   * @type {string}
   * @memberof Activity
   */
  user_agent?: string
  /**
   * Collection identifier in which the item resides.
   * @type {string | Collections}
   * @memberof Activity
   */
  collection?: string | Collections
  /**
   * Unique identifier for the item the action applied to. This is always a string, even for integer primary keys.
   * @type {string}
   * @memberof Activity
   */
  item?: string
  /**
   * User comment. This will store the comments that show up in the right sidebar of the item edit page in the admin app.
   * @type {string}
   * @memberof Activity
   */
  comment?: string | null
  /**
   *
   * @type {Array<number | Revisions>}
   * @memberof Activity
   */
  revisions?: Array<number | Revisions>
}

export const ActivityActionEnum = {
  Create: 'create',
  Update: 'update',
  Delete: 'delete',
  Login: 'login',
} as const

export type ActivityActionEnum =
  typeof ActivityActionEnum[keyof typeof ActivityActionEnum]

/**
 *
 * @export
 * @interface Collections
 */
export interface Collections {
  /**
   * The collection key.
   * @type {string}
   * @memberof Collections
   */
  collection?: string
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  icon?: string | null
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  note?: string | null
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  display_template?: string | null
  /**
   *
   * @type {boolean}
   * @memberof Collections
   */
  hidden?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Collections
   */
  singleton?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof Collections
   */
  translations?: Array<string> | null
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  archive_field?: string | null
  /**
   *
   * @type {boolean}
   * @memberof Collections
   */
  archive_app_filter?: boolean
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  archive_value?: string | null
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  unarchive_value?: string | null
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  sort_field?: string | null
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  accountability?: string | null
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  color?: string | null
  /**
   *
   * @type {Array<string>}
   * @memberof Collections
   */
  item_duplication_fields?: Array<string> | null
  /**
   *
   * @type {number}
   * @memberof Collections
   */
  sort?: number | null
  /**
   *
   * @type {string | Collections}
   * @memberof Collections
   */
  group?: string | Collections | null
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  collapse?: string
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  collection_divider?: string
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  archive_divider?: string
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  sort_divider?: string
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  accountability_divider?: string
  /**
   *
   * @type {string}
   * @memberof Collections
   */
  duplication_divider?: string
}
/**
 * Metadata of the collection.
 * @export
 * @interface CollectionsIdMeta
 */
export interface CollectionsIdMeta {
  /**
   * Name of a Google Material Design Icon that\'s assigned to this collection.
   * @type {string}
   * @memberof CollectionsIdMeta
   */
  icon?: string | null
  /**
   * Choose the color for the icon assigned to this collection.
   * @type {string}
   * @memberof CollectionsIdMeta
   */
  color?: string | null
  /**
   * A note describing the collection.
   * @type {string}
   * @memberof CollectionsIdMeta
   */
  note?: string | null
  /**
   * Text representation of how items from this collection are shown across the system.
   * @type {string}
   * @memberof CollectionsIdMeta
   */
  display_template?: string | null
  /**
   * Whether or not the collection is hidden from the navigation in the admin app.
   * @type {boolean}
   * @memberof CollectionsIdMeta
   */
  hidden?: boolean
  /**
   * Whether or not the collection is treated as a single object.
   * @type {boolean}
   * @memberof CollectionsIdMeta
   */
  singleton?: boolean
  /**
   * Key value pairs of how to show this collection\'s name in different languages in the admin app.
   * @type {string}
   * @memberof CollectionsIdMeta
   */
  translation?: string | null
  /**
   * What field holds the archive value.
   * @type {string}
   * @memberof CollectionsIdMeta
   */
  archive_field?: string | null
  /**
   * What value to use for \"archived\" items.
   * @type {string}
   * @memberof CollectionsIdMeta
   */
  archive_app_filter?: string | null
  /**
   * What value to use to \"unarchive\" items.
   * @type {string}
   * @memberof CollectionsIdMeta
   */
  archive_value?: string | null
  /**
   * Whether or not to show the \"archived\" filter.
   * @type {string}
   * @memberof CollectionsIdMeta
   */
  unarchive_value?: string | null
  /**
   * The sort field in the collection.
   * @type {string}
   * @memberof CollectionsIdMeta
   */
  sort_field?: string | null
}
/**
 *
 * @export
 * @interface Fields
 */
export interface Fields {
  /**
   *
   * @type {number}
   * @memberof Fields
   */
  id?: number
  /**
   * Unique name of the collection this field is in.
   * @type {string}
   * @memberof Fields
   */
  collection?: string
  /**
   * Unique name of the field. Field name is unique within the collection.
   * @type {string}
   * @memberof Fields
   */
  field?: string
  /**
   *
   * @type {Array<string>}
   * @memberof Fields
   */
  special?: Array<string> | null
  /**
   *
   * @type {string}
   * @memberof Fields
   */
  interface?: string | null
  /**
   *
   * @type {Array<string>}
   * @memberof Fields
   */
  options?: Array<string> | null
  /**
   *
   * @type {string}
   * @memberof Fields
   */
  display?: string | null
  /**
   *
   * @type {Array<string>}
   * @memberof Fields
   */
  display_options?: Array<string> | null
  /**
   *
   * @type {boolean}
   * @memberof Fields
   */
  readonly?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Fields
   */
  hidden?: boolean
  /**
   *
   * @type {number}
   * @memberof Fields
   */
  sort?: number | null
  /**
   *
   * @type {string}
   * @memberof Fields
   */
  width?: string | null
  /**
   *
   * @type {Array<string>}
   * @memberof Fields
   */
  translations?: Array<string> | null
  /**
   *
   * @type {string}
   * @memberof Fields
   */
  note?: string | null
  /**
   *
   * @type {Array<string>}
   * @memberof Fields
   */
  conditions?: Array<string> | null
  /**
   *
   * @type {boolean}
   * @memberof Fields
   */
  required?: boolean | null
  /**
   *
   * @type {number | Fields}
   * @memberof Fields
   */
  group?: number | Fields | null
}
/**
 * The meta info.
 * @export
 * @interface FieldsCollectionMeta
 */
export interface FieldsCollectionMeta {
  /**
   * Unique identifier for the field in the `directus_fields` collection.
   * @type {number}
   * @memberof FieldsCollectionMeta
   */
  id?: number
  /**
   * Unique name of the collection this field is in.
   * @type {string}
   * @memberof FieldsCollectionMeta
   */
  collection?: string
  /**
   * Unique name of the field. Field name is unique within the collection.
   * @type {string}
   * @memberof FieldsCollectionMeta
   */
  field?: string
  /**
   * Transformation flag for field
   * @type {Array<string>}
   * @memberof FieldsCollectionMeta
   */
  special?: Array<string> | null
  /**
   * What interface is used in the admin app to edit the value for this field.
   * @type {string}
   * @memberof FieldsCollectionMeta
   */
  'system-interface'?: string | null
  /**
   * Options for the interface that\'s used. This format is based on the individual interface.
   * @type {object}
   * @memberof FieldsCollectionMeta
   */
  options?: object | null
  /**
   * What display is used in the admin app to display the value for this field.
   * @type {string}
   * @memberof FieldsCollectionMeta
   */
  display?: string | null
  /**
   * Options for the display that\'s used. This format is based on the individual display.
   * @type {object}
   * @memberof FieldsCollectionMeta
   */
  display_options?: object | null
  /**
   * If the field can be altered by the end user. Directus system fields have this value set to `true`.
   * @type {boolean}
   * @memberof FieldsCollectionMeta
   */
  locked?: boolean
  /**
   * Prevents the user from editing the value in the field.
   * @type {boolean}
   * @memberof FieldsCollectionMeta
   */
  readonly?: boolean
  /**
   * If this field should be hidden.
   * @type {boolean}
   * @memberof FieldsCollectionMeta
   */
  hidden?: boolean
  /**
   * Sort order of this field on the edit page of the admin app.
   * @type {number}
   * @memberof FieldsCollectionMeta
   */
  sort?: number | null
  /**
   * Width of the field on the edit form.
   * @type {string}
   * @memberof FieldsCollectionMeta
   */
  width?: FieldsCollectionMetaWidthEnum
  /**
   * What field group this field is part of.
   * @type {number}
   * @memberof FieldsCollectionMeta
   */
  group?: number | null
  /**
   * Key value pair of `<language>: <translation>` that allows the user to change the displayed name of the field in the admin app.
   * @type {object}
   * @memberof FieldsCollectionMeta
   */
  translation?: object | null
  /**
   * A user provided note for the field. Will be rendered alongside the interface on the edit page.
   * @type {string}
   * @memberof FieldsCollectionMeta
   */
  note?: string | null
}

export const FieldsCollectionMetaWidthEnum = {
  Half: 'half',
  HalfLeft: 'half-left',
  HalfRight: 'half-right',
  Full: 'full',
  Fill: 'fill',
  Null: 'null',
} as const

export type FieldsCollectionMetaWidthEnum =
  typeof FieldsCollectionMetaWidthEnum[keyof typeof FieldsCollectionMetaWidthEnum]

/**
 * The schema info.
 * @export
 * @interface FieldsCollectionSchema
 */
export interface FieldsCollectionSchema {
  /**
   * The name of the field.
   * @type {string}
   * @memberof FieldsCollectionSchema
   */
  name?: string
  /**
   * The collection of the field.
   * @type {string}
   * @memberof FieldsCollectionSchema
   */
  table?: string
  /**
   * The type of the field.
   * @type {string}
   * @memberof FieldsCollectionSchema
   */
  type?: string
  /**
   * The default value of the field.
   * @type {string}
   * @memberof FieldsCollectionSchema
   */
  default_value?: string | null
  /**
   * The max length of the field.
   * @type {number}
   * @memberof FieldsCollectionSchema
   */
  max_length?: number | null
  /**
   * If the field is nullable.
   * @type {boolean}
   * @memberof FieldsCollectionSchema
   */
  is_nullable?: boolean
  /**
   * If the field is primary key.
   * @type {boolean}
   * @memberof FieldsCollectionSchema
   */
  is_primary_key?: boolean
  /**
   * If the field has auto increment.
   * @type {boolean}
   * @memberof FieldsCollectionSchema
   */
  has_auto_increment?: boolean
  /**
   * Related column from the foreign key constraint.
   * @type {string}
   * @memberof FieldsCollectionSchema
   */
  foreign_key_column?: string | null
  /**
   * Related table from the foreign key constraint.
   * @type {string}
   * @memberof FieldsCollectionSchema
   */
  foreign_key_table?: string | null
  /**
   * Comment as saved in the database.
   * @type {string}
   * @memberof FieldsCollectionSchema
   */
  comment?: string | null
  /**
   * Database schema (pg only).
   * @type {string}
   * @memberof FieldsCollectionSchema
   */
  schema?: string
  /**
   * Related schema from the foreign key constraint (pg only).
   * @type {string}
   * @memberof FieldsCollectionSchema
   */
  foreign_key_schema?: string | null
}
/**
 *
 * @export
 * @interface Files
 */
export interface Files {
  /**
   * Unique identifier for the file.
   * @type {string}
   * @memberof Files
   */
  id?: string
  /**
   * Where the file is stored. Either `local` for the local filesystem or the name of the storage adapter (for example `s3`).
   * @type {string}
   * @memberof Files
   */
  storage?: string
  /**
   * Name of the file on disk. By default, Directus uses a random hash for the filename.
   * @type {string}
   * @memberof Files
   */
  filename_disk?: string
  /**
   * How you want to the file to be named when it\'s being downloaded.
   * @type {string}
   * @memberof Files
   */
  filename_download?: string
  /**
   * Title for the file. Is extracted from the filename on upload, but can be edited by the user.
   * @type {string}
   * @memberof Files
   */
  title?: string
  /**
   * MIME type of the file.
   * @type {string}
   * @memberof Files
   */
  type?: string
  /**
   * Virtual folder where this file resides in.
   * @type {string | Folders}
   * @memberof Files
   */
  folder?: string | Folders | null
  /**
   * Who uploaded the file.
   * @type {string | Users}
   * @memberof Files
   */
  uploaded_by?: string | Users
  /**
   * When the file was uploaded.
   * @type {string}
   * @memberof Files
   */
  uploaded_on?: string
  /**
   *
   * @type {string | Users}
   * @memberof Files
   */
  modified_by?: string | Users | null
  /**
   *
   * @type {string}
   * @memberof Files
   */
  modified_on?: string
  /**
   * Character set of the file.
   * @type {string}
   * @memberof Files
   */
  charset?: string | null
  /**
   * Size of the file in bytes.
   * @type {number}
   * @memberof Files
   */
  filesize?: number
  /**
   * Width of the file in pixels. Only applies to images.
   * @type {number}
   * @memberof Files
   */
  width?: number | null
  /**
   * Height of the file in pixels. Only applies to images.
   * @type {number}
   * @memberof Files
   */
  height?: number | null
  /**
   * Duration of the file in seconds. Only applies to audio and video.
   * @type {number}
   * @memberof Files
   */
  duration?: number | null
  /**
   * Where the file was embedded from.
   * @type {string}
   * @memberof Files
   */
  embed?: string | null
  /**
   * Description for the file.
   * @type {string}
   * @memberof Files
   */
  description?: string | null
  /**
   * Where the file was created. Is automatically populated based on EXIF data for images.
   * @type {string}
   * @memberof Files
   */
  location?: string | null
  /**
   * Tags for the file. Is automatically populated based on EXIF data for images.
   * @type {Array<string>}
   * @memberof Files
   */
  tags?: Array<string> | null
  /**
   * IPTC, EXIF, and ICC metadata extracted from file
   * @type {object}
   * @memberof Files
   */
  metadata?: object | null
  /**
   *
   * @type {string}
   * @memberof Files
   */
  storage_divider?: string
}
/**
 *
 * @export
 * @interface Folders
 */
export interface Folders {
  /**
   * Unique identifier for the folder.
   * @type {string}
   * @memberof Folders
   */
  id?: string
  /**
   * Name of the folder.
   * @type {string}
   * @memberof Folders
   */
  name?: string
  /**
   * Unique identifier of the parent folder. This allows for nested folders.
   * @type {string | Folders}
   * @memberof Folders
   */
  parent?: string | Folders | null
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   * Email address of the user you\'re retrieving the access token for.
   * @type {string}
   * @memberof InlineObject
   */
  email: string
  /**
   * Password of the user.
   * @type {string}
   * @memberof InlineObject
   */
  password: string
  /**
   * Choose between retrieving the token as a string, or setting it as a cookie.
   * @type {string}
   * @memberof InlineObject
   */
  mode?: InlineObjectModeEnum
  /**
   * If 2FA is enabled, you need to pass the one time password.
   * @type {string}
   * @memberof InlineObject
   */
  otp?: string
}

export const InlineObjectModeEnum = {
  Json: 'json',
  Cookie: 'cookie',
} as const

export type InlineObjectModeEnum =
  typeof InlineObjectModeEnum[keyof typeof InlineObjectModeEnum]

/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   * JWT access token you want to refresh. This token can\'t be expired.
   * @type {string}
   * @memberof InlineObject1
   */
  refresh_token?: string
}
/**
 *
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
  /**
   * Unique name of the field. Field name is unique within the collection.
   * @type {string}
   * @memberof InlineObject10
   */
  field?: string
  /**
   * Directus specific data type. Used to cast values in the API.
   * @type {string}
   * @memberof InlineObject10
   */
  type?: string
  /**
   *
   * @type {FieldsCollectionSchema}
   * @memberof InlineObject10
   */
  schema?: FieldsCollectionSchema
  /**
   *
   * @type {FieldsCollectionMeta}
   * @memberof InlineObject10
   */
  meta?: FieldsCollectionMeta | null
}
/**
 *
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
  /**
   *
   * @type {string}
   * @memberof InlineObject11
   */
  data?: string
}
/**
 *
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
  /**
   * Title for the file. Is extracted from the filename on upload, but can be edited by the user.
   * @type {string}
   * @memberof InlineObject12
   */
  title?: string
  /**
   * Preferred filename when file is downloaded.
   * @type {string}
   * @memberof InlineObject12
   */
  filename_download?: string
  /**
   * Description for the file.
   * @type {string}
   * @memberof InlineObject12
   */
  description?: string | null
  /**
   * Virtual folder where this file resides in.
   * @type {string | Folders}
   * @memberof InlineObject12
   */
  folder?: string | Folders | null
  /**
   * Tags for the file. Is automatically populated based on EXIF data for images.
   * @type {Array<string>}
   * @memberof InlineObject12
   */
  tags?: Array<string> | null
  /**
   * File contents.
   * @type {any}
   * @memberof InlineObject12
   */
  file: any
}
/**
 *
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
  /**
   * Name of the folder.
   * @type {string}
   * @memberof InlineObject13
   */
  name: string
  /**
   * Unique identifier of the parent folder. This allows for nested folders.
   * @type {number}
   * @memberof InlineObject13
   */
  parent?: number
}
/**
 *
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
  /**
   * Name of the folder. Can\'t be null or empty.
   * @type {string}
   * @memberof InlineObject14
   */
  name?: string
  /**
   * Unique identifier of the parent folder. This allows for nested folders.
   * @type {number}
   * @memberof InlineObject14
   */
  parent?: number
}
/**
 *
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
  /**
   * What collection this permission applies to.
   * @type {string}
   * @memberof InlineObject15
   */
  collection?: string
  /**
   * If the user can post comments.
   * @type {string}
   * @memberof InlineObject15
   */
  comment?: InlineObject15CommentEnum
  /**
   * If the user can create items.
   * @type {string}
   * @memberof InlineObject15
   */
  create?: InlineObject15CreateEnum
  /**
   * If the user can update items.
   * @type {string}
   * @memberof InlineObject15
   */
  delete?: InlineObject15DeleteEnum
  /**
   * If the user is required to leave a comment explaining what was changed.
   * @type {string}
   * @memberof InlineObject15
   */
  explain?: InlineObject15ExplainEnum
  /**
   * If the user can read items.
   * @type {string}
   * @memberof InlineObject15
   */
  read?: InlineObject15ReadEnum
  /**
   * Unique identifier of the role this permission applies to.
   * @type {number}
   * @memberof InlineObject15
   */
  role?: number
  /**
   * Explicitly denies read access for specific fields.
   * @type {Array<string>}
   * @memberof InlineObject15
   */
  read_field_blacklist?: Array<string>
  /**
   * What status this permission applies to.
   * @type {string}
   * @memberof InlineObject15
   */
  status?: string
  /**
   * Explicitly denies specific statuses to be used.
   * @type {Array<string>}
   * @memberof InlineObject15
   */
  status_blacklist?: Array<string>
  /**
   * If the user can update items.
   * @type {string}
   * @memberof InlineObject15
   */
  update?: InlineObject15UpdateEnum
  /**
   * Explicitly denies write access for specific fields.
   * @type {Array<string>}
   * @memberof InlineObject15
   */
  write_field_blacklist?: Array<string>
}

export const InlineObject15CommentEnum = {
  None: 'none',
  Create: 'create',
  Update: 'update',
  Full: 'full',
} as const

export type InlineObject15CommentEnum =
  typeof InlineObject15CommentEnum[keyof typeof InlineObject15CommentEnum]
export const InlineObject15CreateEnum = {
  None: 'none',
  Full: 'full',
} as const

export type InlineObject15CreateEnum =
  typeof InlineObject15CreateEnum[keyof typeof InlineObject15CreateEnum]
export const InlineObject15DeleteEnum = {
  None: 'none',
  Mine: 'mine',
  Role: 'role',
  Full: 'full',
} as const

export type InlineObject15DeleteEnum =
  typeof InlineObject15DeleteEnum[keyof typeof InlineObject15DeleteEnum]
export const InlineObject15ExplainEnum = {
  None: 'none',
  Create: 'create',
  Update: 'update',
  Always: 'always',
} as const

export type InlineObject15ExplainEnum =
  typeof InlineObject15ExplainEnum[keyof typeof InlineObject15ExplainEnum]
export const InlineObject15ReadEnum = {
  None: 'none',
  Mine: 'mine',
  Role: 'role',
  Full: 'full',
} as const

export type InlineObject15ReadEnum =
  typeof InlineObject15ReadEnum[keyof typeof InlineObject15ReadEnum]
export const InlineObject15UpdateEnum = {
  None: 'none',
  Mine: 'mine',
  Role: 'role',
  Full: 'full',
} as const

export type InlineObject15UpdateEnum =
  typeof InlineObject15UpdateEnum[keyof typeof InlineObject15UpdateEnum]

/**
 *
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
  /**
   * What collection this permission applies to.
   * @type {object}
   * @memberof InlineObject16
   */
  collection?: object
  /**
   * If the user can post comments. `full`.
   * @type {string}
   * @memberof InlineObject16
   */
  comment?: InlineObject16CommentEnum
  /**
   * If the user can create items.
   * @type {string}
   * @memberof InlineObject16
   */
  create?: InlineObject16CreateEnum
  /**
   * If the user can update items.
   * @type {string}
   * @memberof InlineObject16
   */
  delete?: InlineObject16DeleteEnum
  /**
   * If the user is required to leave a comment explaining what was changed.
   * @type {string}
   * @memberof InlineObject16
   */
  explain?: InlineObject16ExplainEnum
  /**
   * If the user can read items.
   * @type {string}
   * @memberof InlineObject16
   */
  read?: InlineObject16ReadEnum
  /**
   * Explicitly denies read access for specific fields.
   * @type {object}
   * @memberof InlineObject16
   */
  read_field_blacklist?: object
  /**
   * Unique identifier of the role this permission applies to.
   * @type {object}
   * @memberof InlineObject16
   */
  role?: object
  /**
   * What status this permission applies to.
   * @type {object}
   * @memberof InlineObject16
   */
  status?: object
  /**
   * Explicitly denies specific statuses to be used.
   * @type {object}
   * @memberof InlineObject16
   */
  status_blacklist?: object
  /**
   * If the user can update items.
   * @type {string}
   * @memberof InlineObject16
   */
  update?: InlineObject16UpdateEnum
  /**
   * Explicitly denies write access for specific fields.
   * @type {object}
   * @memberof InlineObject16
   */
  write_field_blacklist?: object
}

export const InlineObject16CommentEnum = {
  None: 'none',
  Create: 'create',
  Update: 'update',
} as const

export type InlineObject16CommentEnum =
  typeof InlineObject16CommentEnum[keyof typeof InlineObject16CommentEnum]
export const InlineObject16CreateEnum = {
  None: 'none',
  Full: 'full',
} as const

export type InlineObject16CreateEnum =
  typeof InlineObject16CreateEnum[keyof typeof InlineObject16CreateEnum]
export const InlineObject16DeleteEnum = {
  None: 'none',
  Mine: 'mine',
  Role: 'role',
  Full: 'full',
} as const

export type InlineObject16DeleteEnum =
  typeof InlineObject16DeleteEnum[keyof typeof InlineObject16DeleteEnum]
export const InlineObject16ExplainEnum = {
  None: 'none',
  Create: 'create',
  Update: 'update',
  Always: 'always',
} as const

export type InlineObject16ExplainEnum =
  typeof InlineObject16ExplainEnum[keyof typeof InlineObject16ExplainEnum]
export const InlineObject16ReadEnum = {
  None: 'none',
  Mine: 'mine',
  Role: 'role',
  Full: 'full',
} as const

export type InlineObject16ReadEnum =
  typeof InlineObject16ReadEnum[keyof typeof InlineObject16ReadEnum]
export const InlineObject16UpdateEnum = {
  None: 'none',
  Mine: 'mine',
  Role: 'role',
  Full: 'full',
} as const

export type InlineObject16UpdateEnum =
  typeof InlineObject16UpdateEnum[keyof typeof InlineObject16UpdateEnum]

/**
 *
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
  /**
   * What collection this collection preset is used for.
   * @type {string}
   * @memberof InlineObject17
   */
  collection: string
  /**
   * Name for the bookmark. If this is set, the collection preset will be considered to be a bookmark.
   * @type {string}
   * @memberof InlineObject17
   */
  title?: string
  /**
   * The unique identifier of a role in the platform. If user is null, this will be used to apply the collection preset or bookmark for all users in the role.
   * @type {string}
   * @memberof InlineObject17
   */
  role?: string
  /**
   * What the user searched for in search/filter in the header bar.
   * @type {string}
   * @memberof InlineObject17
   */
  search?: string
  /**
   *
   * @type {Array<PresetsFilters>}
   * @memberof InlineObject17
   */
  filters?: Array<PresetsFilters>
  /**
   * Name of the view type that is used.
   * @type {string}
   * @memberof InlineObject17
   */
  layout?: string
  /**
   * Layout query that\'s saved per layout type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters.
   * @type {string}
   * @memberof InlineObject17
   */
  layout_query?: string
  /**
   * Options of the views. The properties in here are controlled by the layout.
   * @type {string}
   * @memberof InlineObject17
   */
  layout_options?: string
}
/**
 *
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
  /**
   * What collection this collection preset is used for.
   * @type {string}
   * @memberof InlineObject18
   */
  collection: string
  /**
   * Name for the bookmark. If this is set, the collection preset will be considered to be a bookmark.
   * @type {string}
   * @memberof InlineObject18
   */
  title?: string
  /**
   * The unique identifier of a role in the platform. If user is null, this will be used to apply the collection preset or bookmark for all users in the role.
   * @type {number}
   * @memberof InlineObject18
   */
  role?: number
  /**
   * What the user searched for in search/filter in the header bar.
   * @type {string}
   * @memberof InlineObject18
   */
  search_query?: string
  /**
   *
   * @type {Array<PresetsIdFilters>}
   * @memberof InlineObject18
   */
  filters?: Array<PresetsIdFilters>
  /**
   * Name of the view type that is used. Defaults to tabular.
   * @type {string}
   * @memberof InlineObject18
   */
  view_type?: string
  /**
   * View query that\'s saved per view type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters.
   * @type {string}
   * @memberof InlineObject18
   */
  view_query?: string
  /**
   * Options of the views. The properties in here are controlled by the layout.
   * @type {string}
   * @memberof InlineObject18
   */
  view_options?: string
  /**
   * Key value pair of language-translation. Can be used to translate the bookmark title in multiple languages.
   * @type {object}
   * @memberof InlineObject18
   */
  translation?: object
}
/**
 *
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
  /**
   * Collection that has the field that holds the foreign key.
   * @type {string}
   * @memberof InlineObject19
   */
  collection_many?: string
  /**
   * Collection on the _one_ side of the relationship.
   * @type {string}
   * @memberof InlineObject19
   */
  collection_one?: string
  /**
   * Foreign key. Field that holds the primary key of the related collection.
   * @type {string}
   * @memberof InlineObject19
   */
  field_many?: string
  /**
   * Alias column that serves as the _one_ side of the relationship.
   * @type {string}
   * @memberof InlineObject19
   */
  field_one?: string
  /**
   * Field on the junction table that holds the primary key of the related collection.
   * @type {string}
   * @memberof InlineObject19
   */
  junction_field?: string
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
  /**
   * JWT access token you want to logout.
   * @type {string}
   * @memberof InlineObject2
   */
  refresh_token?: string
}
/**
 *
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
  /**
   * Collection that has the field that holds the foreign key.
   * @type {string}
   * @memberof InlineObject20
   */
  collection_many?: string
  /**
   * Collection on the _one_ side of the relationship.
   * @type {string}
   * @memberof InlineObject20
   */
  collection_one?: string
  /**
   * Foreign key. Field that holds the primary key of the related collection.
   * @type {string}
   * @memberof InlineObject20
   */
  field_many?: string
  /**
   * Alias column that serves as the _one_ side of the relationship.
   * @type {string}
   * @memberof InlineObject20
   */
  field_one?: string
  /**
   * Field on the junction table that holds the primary key of the related collection.
   * @type {string}
   * @memberof InlineObject20
   */
  junction_field?: string
}
/**
 *
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
  /**
   * Description of the role.
   * @type {string}
   * @memberof InlineObject21
   */
  description?: string
  /**
   * Whether or not this role enforces the use of 2FA.
   * @type {boolean}
   * @memberof InlineObject21
   */
  enforce_2fa?: boolean
  /**
   * ID used with external services in SCIM.
   * @type {string}
   * @memberof InlineObject21
   */
  external_id?: string
  /**
   * Array of IP addresses that are allowed to connect to the API as a user of this role.
   * @type {Array<string>}
   * @memberof InlineObject21
   */
  ip_whitelist?: Array<string>
  /**
   * Custom override for the admin app module bar navigation.
   * @type {string}
   * @memberof InlineObject21
   */
  module_listing?: string
  /**
   * Name of the role.
   * @type {string}
   * @memberof InlineObject21
   */
  name?: string
}
/**
 *
 * @export
 * @interface InlineObject22
 */
export interface InlineObject22 {
  /**
   * Description of the role.
   * @type {string}
   * @memberof InlineObject22
   */
  description?: string
  /**
   * Whether or not this role enforces the use of 2FA.
   * @type {boolean}
   * @memberof InlineObject22
   */
  enforce_2fa?: boolean
  /**
   * ID used with external services in SCIM.
   * @type {string}
   * @memberof InlineObject22
   */
  external_id?: string
  /**
   * Array of IP addresses that are allowed to connect to the API as a user of this role.
   * @type {Array<string>}
   * @memberof InlineObject22
   */
  ip_whitelist?: Array<string>
  /**
   * Custom override for the admin app module bar navigation.
   * @type {string}
   * @memberof InlineObject22
   */
  module_listing?: string
  /**
   * Name of the role.
   * @type {string}
   * @memberof InlineObject22
   */
  name?: string
}
/**
 *
 * @export
 * @interface InlineObject23
 */
export interface InlineObject23 {
  /**
   * Email address or array of email addresses of the to-be-invited user(s).
   * @type {string}
   * @memberof InlineObject23
   */
  email?: string
}
/**
 *
 * @export
 * @interface InlineObject24
 */
export interface InlineObject24 {
  /**
   * Accept invite token.
   * @type {string}
   * @memberof InlineObject24
   */
  token?: string
  /**
   * Password of the user.
   * @type {string}
   * @memberof InlineObject24
   */
  password?: string
}
/**
 *
 * @export
 * @interface InlineObject25
 */
export interface InlineObject25 {
  /**
   * Path of the page you used last.
   * @type {string}
   * @memberof InlineObject25
   */
  last_page?: string
}
/**
 *
 * @export
 * @interface InlineObject26
 */
export interface InlineObject26 {
  /**
   * The name of the webhook.
   * @type {string}
   * @memberof InlineObject26
   */
  name?: string
  /**
   * Method used in the webhook.
   * @type {string}
   * @memberof InlineObject26
   */
  method?: string
  /**
   * The url of the webhook.
   * @type {string}
   * @memberof InlineObject26
   */
  url?: string
  /**
   * The status of the webhook.
   * @type {string}
   * @memberof InlineObject26
   */
  status?: string
  /**
   * If yes, send the content of what was done
   * @type {boolean}
   * @memberof InlineObject26
   */
  data?: boolean
  /**
   * The actions that triggers this webhook.
   * @type {any}
   * @memberof InlineObject26
   */
  actions?: any
  /**
   * The collections that triggers this webhook.
   * @type {any}
   * @memberof InlineObject26
   */
  'system-collections'?: any
}
/**
 *
 * @export
 * @interface InlineObject27
 */
export interface InlineObject27 {
  /**
   * The name of the webhook.
   * @type {string}
   * @memberof InlineObject27
   */
  name?: string
  /**
   * Method used in the webhook.
   * @type {string}
   * @memberof InlineObject27
   */
  method?: string
  /**
   * The url of the webhook.
   * @type {string}
   * @memberof InlineObject27
   */
  url?: string
  /**
   * The status of the webhook.
   * @type {string}
   * @memberof InlineObject27
   */
  status?: string
  /**
   * If yes, send the content of what was done
   * @type {boolean}
   * @memberof InlineObject27
   */
  data?: boolean
  /**
   * The actions that triggers this webhook.
   * @type {any}
   * @memberof InlineObject27
   */
  actions?: any
  /**
   * The collections that triggers this webhook.
   * @type {any}
   * @memberof InlineObject27
   */
  'system-collections'?: any
}
/**
 *
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
  /**
   * Email address of the user you\'re requesting a reset for.
   * @type {string}
   * @memberof InlineObject3
   */
  email: string
}
/**
 *
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
  /**
   * One-time use JWT token that is used to verify the user.
   * @type {string}
   * @memberof InlineObject4
   */
  token: string
  /**
   * New password for the user.
   * @type {string}
   * @memberof InlineObject4
   */
  password: string
}
/**
 *
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
  /**
   *
   * @type {string}
   * @memberof InlineObject5
   */
  collection: string
  /**
   *
   * @type {number}
   * @memberof InlineObject5
   */
  item: number
  /**
   *
   * @type {string}
   * @memberof InlineObject5
   */
  comment: string
}
/**
 *
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
  /**
   *
   * @type {string}
   * @memberof InlineObject6
   */
  comment?: string
}
/**
 *
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
  /**
   * Unique name of the collection.
   * @type {string}
   * @memberof InlineObject7
   */
  collection: string
  /**
   * The fields contained in this collection. See the fields reference for more information. Each individual field requires field, type, and interface to be provided.
   * @type {Array<object>}
   * @memberof InlineObject7
   */
  fields: Array<object>
  /**
   * Name of a Google Material Design Icon that\'s assigned to this collection.
   * @type {string}
   * @memberof InlineObject7
   */
  icon?: string | null
  /**
   * A note describing the collection.
   * @type {string}
   * @memberof InlineObject7
   */
  note?: string | null
  /**
   * Text representation of how items from this collection are shown across the system.
   * @type {string}
   * @memberof InlineObject7
   */
  display_template?: string | null
  /**
   * Whether or not the collection is hidden from the navigation in the admin app.
   * @type {boolean}
   * @memberof InlineObject7
   */
  hidden?: boolean
  /**
   * Whether or not the collection is treated as a single object.
   * @type {boolean}
   * @memberof InlineObject7
   */
  singleton?: boolean
  /**
   * Key value pairs of how to show this collection\'s name in different languages in the admin app.
   * @type {string}
   * @memberof InlineObject7
   */
  translation?: string | null
  /**
   * What field holds the archive value.
   * @type {string}
   * @memberof InlineObject7
   */
  archive_field?: string | null
  /**
   * What value to use for \"archived\" items.
   * @type {string}
   * @memberof InlineObject7
   */
  archive_app_filter?: string | null
  /**
   * What value to use to \"unarchive\" items.
   * @type {string}
   * @memberof InlineObject7
   */
  archive_value?: string | null
  /**
   * Whether or not to show the \"archived\" filter.
   * @type {string}
   * @memberof InlineObject7
   */
  unarchive_value?: string | null
  /**
   * The sort field in the collection.
   * @type {string}
   * @memberof InlineObject7
   */
  sort_field?: string | null
}
/**
 *
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
  /**
   *
   * @type {CollectionsIdMeta}
   * @memberof InlineObject8
   */
  meta?: CollectionsIdMeta
}
/**
 *
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
  /**
   * Unique name of the field. Field name is unique within the collection.
   * @type {string}
   * @memberof InlineObject9
   */
  field: string
  /**
   * Directus specific data type. Used to cast values in the API.
   * @type {string}
   * @memberof InlineObject9
   */
  type: string
  /**
   *
   * @type {FieldsCollectionSchema}
   * @memberof InlineObject9
   */
  schema?: FieldsCollectionSchema
  /**
   *
   * @type {FieldsCollectionMeta}
   * @memberof InlineObject9
   */
  meta?: FieldsCollectionMeta | null
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {InlineResponse200Data}
   * @memberof InlineResponse200
   */
  data?: InlineResponse200Data
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {InlineResponse2001Data}
   * @memberof InlineResponse2001
   */
  data?: InlineResponse2001Data
}
/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
  /**
   *
   * @type {Array<Activity>}
   * @memberof InlineResponse20010
   */
  data?: Array<Activity>
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
  /**
   *
   * @type {Activity}
   * @memberof InlineResponse20011
   */
  data?: Activity
}
/**
 *
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
  /**
   *
   * @type {Array<Collections>}
   * @memberof InlineResponse20012
   */
  data?: Array<Collections>
}
/**
 *
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
  /**
   *
   * @type {Collections}
   * @memberof InlineResponse20013
   */
  data?: Collections
}
/**
 *
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
  /**
   *
   * @type {Array<Fields>}
   * @memberof InlineResponse20014
   */
  data?: Array<Fields>
}
/**
 *
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
  /**
   *
   * @type {Fields}
   * @memberof InlineResponse20015
   */
  data?: Fields
}
/**
 *
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
  /**
   *
   * @type {Array<Files>}
   * @memberof InlineResponse20016
   */
  data?: Array<Files>
}
/**
 *
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
  /**
   *
   * @type {Files}
   * @memberof InlineResponse20017
   */
  data?: Files
}
/**
 *
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
  /**
   *
   * @type {Array<Folders>}
   * @memberof InlineResponse20018
   */
  data?: Array<Folders>
}
/**
 *
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
  /**
   *
   * @type {Folders}
   * @memberof InlineResponse20019
   */
  data?: Folders
}
/**
 *
 * @export
 * @interface InlineResponse2001Data
 */
export interface InlineResponse2001Data {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001Data
   */
  access_token?: string
  /**
   *
   * @type {number}
   * @memberof InlineResponse2001Data
   */
  expires?: number
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001Data
   */
  refresh_token?: string
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2002
   */
  public?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse2002
   */
  data?: Array<string>
}
/**
 *
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
  /**
   *
   * @type {Array<Permissions>}
   * @memberof InlineResponse20020
   */
  data?: Array<Permissions>
}
/**
 *
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
  /**
   *
   * @type {Permissions}
   * @memberof InlineResponse20021
   */
  data?: Permissions
}
/**
 *
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
  /**
   *
   * @type {Array<Presets>}
   * @memberof InlineResponse20022
   */
  data?: Array<Presets>
}
/**
 *
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
  /**
   *
   * @type {Presets}
   * @memberof InlineResponse20023
   */
  data?: Presets
}
/**
 *
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
  /**
   *
   * @type {Array<Relations>}
   * @memberof InlineResponse20024
   */
  data?: Array<Relations>
}
/**
 *
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
  /**
   *
   * @type {Relations}
   * @memberof InlineResponse20025
   */
  data?: Relations
}
/**
 *
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
  /**
   *
   * @type {Array<Revisions>}
   * @memberof InlineResponse20026
   */
  data?: Array<Revisions>
}
/**
 *
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
  /**
   *
   * @type {Revisions}
   * @memberof InlineResponse20027
   */
  data?: Revisions
}
/**
 *
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
  /**
   *
   * @type {Array<Roles>}
   * @memberof InlineResponse20028
   */
  data?: Array<Roles>
}
/**
 *
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
  /**
   *
   * @type {Roles}
   * @memberof InlineResponse20029
   */
  data?: Roles
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2003
   */
  public?: boolean
  /**
   *
   * @type {InlineResponse2003Data}
   * @memberof InlineResponse2003
   */
  data?: InlineResponse2003Data
}
/**
 *
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
  /**
   *
   * @type {Settings}
   * @memberof InlineResponse20030
   */
  data?: Settings
}
/**
 *
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
  /**
   *
   * @type {Array<Users>}
   * @memberof InlineResponse20031
   */
  data?: Array<Users>
}
/**
 *
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
  /**
   *
   * @type {Users}
   * @memberof InlineResponse20032
   */
  data?: Users
}
/**
 *
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
  /**
   *
   * @type {Webhooks}
   * @memberof InlineResponse20033
   */
  data?: Webhooks
}
/**
 *
 * @export
 * @interface InlineResponse2003Data
 */
export interface InlineResponse2003Data {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003Data
   */
  token?: string
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   *
   * @type {Array<object>}
   * @memberof InlineResponse2004
   */
  data?: Array<object>
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   *
   * @type {object}
   * @memberof InlineResponse2005
   */
  data?: object
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  data?: string
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
  /**
   *
   * @type {Array<ItemsComment>}
   * @memberof InlineResponse2007
   */
  data?: Array<ItemsComment>
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
  /**
   *
   * @type {Array<ItemsPost>}
   * @memberof InlineResponse2008
   */
  data?: Array<ItemsPost>
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
  /**
   *
   * @type {Array<ItemsPostFiles>}
   * @memberof InlineResponse2009
   */
  data?: Array<ItemsPostFiles>
}
/**
 *
 * @export
 * @interface InlineResponse200Data
 */
export interface InlineResponse200Data {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Data
   */
  access_token?: string
  /**
   *
   * @type {number}
   * @memberof InlineResponse200Data
   */
  expires?: number
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Data
   */
  refresh_token?: string
}
/**
 *
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
  /**
   *
   * @type {InlineResponse404Error}
   * @memberof InlineResponse404
   */
  error?: InlineResponse404Error
}
/**
 *
 * @export
 * @interface InlineResponse404Error
 */
export interface InlineResponse404Error {
  /**
   *
   * @type {number}
   * @memberof InlineResponse404Error
   */
  code?: number
  /**
   *
   * @type {string}
   * @memberof InlineResponse404Error
   */
  message?: string
}
/**
 *
 * @export
 * @interface ItemsComment
 */
export interface ItemsComment {
  /**
   *
   * @type {number}
   * @memberof ItemsComment
   */
  id?: number
  /**
   *
   * @type {string | Users}
   * @memberof ItemsComment
   */
  user_created?: string | Users | null
  /**
   *
   * @type {string}
   * @memberof ItemsComment
   */
  date_created?: string | null
  /**
   *
   * @type {string | Users}
   * @memberof ItemsComment
   */
  user_updated?: string | Users | null
  /**
   *
   * @type {string}
   * @memberof ItemsComment
   */
  date_updated?: string | null
  /**
   *
   * @type {number | ItemsPost}
   * @memberof ItemsComment
   */
  post?: number | ItemsPost | null
  /**
   *
   * @type {string}
   * @memberof ItemsComment
   */
  content?: string | null
}
/**
 *
 * @export
 * @interface ItemsPost
 */
export interface ItemsPost {
  /**
   *
   * @type {number}
   * @memberof ItemsPost
   */
  id?: number
  /**
   *
   * @type {string | Users}
   * @memberof ItemsPost
   */
  user_created?: string | Users | null
  /**
   *
   * @type {string}
   * @memberof ItemsPost
   */
  date_created?: string | null
  /**
   *
   * @type {string | Users}
   * @memberof ItemsPost
   */
  user_updated?: string | Users | null
  /**
   *
   * @type {string}
   * @memberof ItemsPost
   */
  date_updated?: string | null
  /**
   *
   * @type {string}
   * @memberof ItemsPost
   */
  content?: string | null
  /**
   *
   * @type {Array<number | ItemsComment>}
   * @memberof ItemsPost
   */
  comments?: Array<number | ItemsComment>
  /**
   *
   * @type {Array<number | ItemsPostFiles>}
   * @memberof ItemsPost
   */
  files?: Array<number | ItemsPostFiles>
}
/**
 *
 * @export
 * @interface ItemsPostFiles
 */
export interface ItemsPostFiles {
  /**
   *
   * @type {number}
   * @memberof ItemsPostFiles
   */
  id?: number
  /**
   *
   * @type {number | ItemsPost}
   * @memberof ItemsPostFiles
   */
  Post_id?: number | ItemsPost | null
  /**
   *
   * @type {string | Files}
   * @memberof ItemsPostFiles
   */
  directus_files_id?: string | Files | null
}
/**
 *
 * @export
 * @interface Permissions
 */
export interface Permissions {
  /**
   * Unique identifier for the permission.
   * @type {number}
   * @memberof Permissions
   */
  id?: number
  /**
   * Unique identifier of the role this permission applies to.
   * @type {string}
   * @memberof Permissions
   */
  role?: string | null
  /**
   * What collection this permission applies to.
   * @type {string}
   * @memberof Permissions
   */
  collection?: string
  /**
   * What action this permission applies to.
   * @type {string}
   * @memberof Permissions
   */
  action?: PermissionsActionEnum
  /**
   * JSON structure containing the permissions checks for this permission.
   * @type {object}
   * @memberof Permissions
   */
  permissions?: object | null
  /**
   * JSON structure containing the validation checks for this permission.
   * @type {object}
   * @memberof Permissions
   */
  validation?: object | null
  /**
   * JSON structure containing the preset value for created/updated items.
   * @type {object}
   * @memberof Permissions
   */
  presets?: object | null
  /**
   * CSV of fields that the user is allowed to interact with.
   * @type {Array<string>}
   * @memberof Permissions
   */
  fields?: Array<string> | null
}

export const PermissionsActionEnum = {
  Create: 'create',
  Read: 'read',
  Update: 'update',
  Delete: 'delete',
} as const

export type PermissionsActionEnum =
  typeof PermissionsActionEnum[keyof typeof PermissionsActionEnum]

/**
 *
 * @export
 * @interface Presets
 */
export interface Presets {
  /**
   * Unique identifier for this single collection preset.
   * @type {number}
   * @memberof Presets
   */
  id?: number
  /**
   * Name for the bookmark. If this is set, the preset will be considered a bookmark.
   * @type {string}
   * @memberof Presets
   */
  bookmark?: string | null
  /**
   * The unique identifier of the user to whom this collection preset applies.
   * @type {string | Users}
   * @memberof Presets
   */
  user?: string | Users | null
  /**
   * The unique identifier of a role in the platform. If `user` is null, this will be used to apply the collection preset or bookmark for all users in the role.
   * @type {string | Roles}
   * @memberof Presets
   */
  role?: string | Roles | null
  /**
   * What collection this collection preset is used for.
   * @type {string | Collections}
   * @memberof Presets
   */
  collection?: string | Collections
  /**
   * Search query.
   * @type {string}
   * @memberof Presets
   */
  search?: string | null
  /**
   * Key of the layout that is used.
   * @type {string}
   * @memberof Presets
   */
  layout?: string
  /**
   * Layout query that\'s saved per layout type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters.
   * @type {any}
   * @memberof Presets
   */
  layout_query?: any | null
  /**
   * Options of the views. The properties in here are controlled by the layout.
   * @type {any}
   * @memberof Presets
   */
  layout_options?: any | null
  /**
   *
   * @type {number}
   * @memberof Presets
   */
  refresh_interval?: number | null
  /**
   *
   * @type {Array<string>}
   * @memberof Presets
   */
  filter?: Array<string> | null
}
/**
 *
 * @export
 * @interface PresetsFilters
 */
export interface PresetsFilters {
  /**
   *
   * @type {string}
   * @memberof PresetsFilters
   */
  key?: string
  /**
   *
   * @type {string}
   * @memberof PresetsFilters
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof PresetsFilters
   */
  operator?: string
  /**
   *
   * @type {number}
   * @memberof PresetsFilters
   */
  value?: number
}
/**
 *
 * @export
 * @interface PresetsIdFilters
 */
export interface PresetsIdFilters {
  /**
   *
   * @type {string}
   * @memberof PresetsIdFilters
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof PresetsIdFilters
   */
  operator?: string
  /**
   *
   * @type {number}
   * @memberof PresetsIdFilters
   */
  value?: number
}
/**
 *
 * @export
 * @interface Relations
 */
export interface Relations {
  /**
   * Unique identifier for the relation.
   * @type {number}
   * @memberof Relations
   */
  id?: number
  /**
   * Collection that has the field that holds the foreign key.
   * @type {string}
   * @memberof Relations
   */
  many_collection?: string
  /**
   * Foreign key. Field that holds the primary key of the related collection.
   * @type {string}
   * @memberof Relations
   */
  many_field?: string
  /**
   * Collection on the _one_ side of the relationship.
   * @type {string}
   * @memberof Relations
   */
  one_collection?: string
  /**
   * Alias column that serves as the _one_ side of the relationship.
   * @type {string}
   * @memberof Relations
   */
  one_field?: string | null
  /**
   *
   * @type {string}
   * @memberof Relations
   */
  one_collection_field?: string | null
  /**
   *
   * @type {Array<string>}
   * @memberof Relations
   */
  one_allowed_collections?: Array<string> | null
  /**
   * Field on the junction table that holds the many field of the related relation.
   * @type {string}
   * @memberof Relations
   */
  junction_field?: string | null
  /**
   *
   * @type {string}
   * @memberof Relations
   */
  sort_field?: string | null
  /**
   *
   * @type {string}
   * @memberof Relations
   */
  one_deselect_action?: string
}
/**
 *
 * @export
 * @interface Revisions
 */
export interface Revisions {
  /**
   * Unique identifier for the revision.
   * @type {number}
   * @memberof Revisions
   */
  id?: number
  /**
   * Unique identifier for the activity record.
   * @type {number | Activity}
   * @memberof Revisions
   */
  activity?: number | Activity
  /**
   * Collection of the updated item.
   * @type {string | Collections}
   * @memberof Revisions
   */
  collection?: string | Collections
  /**
   * Primary key of updated item.
   * @type {string}
   * @memberof Revisions
   */
  item?: string
  /**
   * Copy of item state at time of update.
   * @type {object}
   * @memberof Revisions
   */
  data?: object | null
  /**
   * Changes between the previous and the current revision.
   * @type {object}
   * @memberof Revisions
   */
  delta?: object
  /**
   * If the current item was updated relationally, this is the id of the parent revision record
   * @type {number}
   * @memberof Revisions
   */
  parent?: number | null
}
/**
 *
 * @export
 * @interface Roles
 */
export interface Roles {
  /**
   * Unique identifier for the role.
   * @type {string}
   * @memberof Roles
   */
  id?: string
  /**
   * Name of the role.
   * @type {string}
   * @memberof Roles
   */
  name?: string
  /**
   * The role\'s icon.
   * @type {string}
   * @memberof Roles
   */
  icon?: string
  /**
   * Description of the role.
   * @type {string}
   * @memberof Roles
   */
  description?: string | null
  /**
   * Array of IP addresses that are allowed to connect to the API as a user of this role.
   * @type {Array<string>}
   * @memberof Roles
   */
  ip_access?: Array<string>
  /**
   * Whether or not this role enforces the use of 2FA.
   * @type {boolean}
   * @memberof Roles
   */
  enforce_tfa?: boolean
  /**
   * Admin role. If true, skips all permission checks.
   * @type {boolean}
   * @memberof Roles
   */
  admin_access?: boolean
  /**
   * The users in the role are allowed to use the app.
   * @type {boolean}
   * @memberof Roles
   */
  app_access?: boolean
  /**
   *
   * @type {Array<string | Users>}
   * @memberof Roles
   */
  users?: Array<string | Users>
}
/**
 *
 * @export
 * @interface Settings
 */
export interface Settings {
  /**
   * Unique identifier for the setting.
   * @type {number}
   * @memberof Settings
   */
  id?: number
  /**
   * The name of the project.
   * @type {string}
   * @memberof Settings
   */
  project_name?: string
  /**
   * The url of the project.
   * @type {string}
   * @memberof Settings
   */
  project_url?: string | null
  /**
   * The brand color of the project.
   * @type {string}
   * @memberof Settings
   */
  project_color?: string | null
  /**
   * The logo of the project.
   * @type {string}
   * @memberof Settings
   */
  project_logo?: string | null
  /**
   * The foreground of the project.
   * @type {string}
   * @memberof Settings
   */
  public_foreground?: string | null
  /**
   * The background of the project.
   * @type {string}
   * @memberof Settings
   */
  public_background?: string | null
  /**
   * Note rendered on the public pages of the app.
   * @type {string}
   * @memberof Settings
   */
  public_note?: string | null
  /**
   * Allowed authentication login attempts before the user\'s status is set to blocked.
   * @type {number}
   * @memberof Settings
   */
  auth_login_attempts?: number
  /**
   * Authentication password policy.
   * @type {string}
   * @memberof Settings
   */
  auth_password_policy?: string | null
  /**
   * What transformations are allowed in the assets endpoint.
   * @type {string}
   * @memberof Settings
   */
  storage_asset_transform?: SettingsStorageAssetTransformEnum
  /**
   * Array of allowed
   * @type {Array<SettingsStorageAssetPresets>}
   * @memberof Settings
   */
  storage_asset_presets?: Array<SettingsStorageAssetPresets> | null
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  custom_css?: string | null
  /**
   * Default folder to place files
   * @type {string}
   * @memberof Settings
   */
  storage_default_folder?: string
  /**
   *
   * @type {Array<string>}
   * @memberof Settings
   */
  basemaps?: Array<string> | null
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  mapbox_key?: string | null
  /**
   *
   * @type {Array<string>}
   * @memberof Settings
   */
  module_bar?: Array<string> | null
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  project_descriptor?: string | null
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  branding_divider?: string
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  modules_divider?: string
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  security_divider?: string
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  files_divider?: string
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  map_divider?: string
}

export const SettingsStorageAssetTransformEnum = {
  All: 'all',
  None: 'none',
  Presets: 'presets',
} as const

export type SettingsStorageAssetTransformEnum =
  typeof SettingsStorageAssetTransformEnum[keyof typeof SettingsStorageAssetTransformEnum]

/**
 *
 * @export
 * @interface SettingsArguments
 */
export interface SettingsArguments {
  /**
   * A JSON representation of the argument value
   * @type {string}
   * @memberof SettingsArguments
   */
  argument?: string
}
/**
 *
 * @export
 * @interface SettingsStorageAssetPresets
 */
export interface SettingsStorageAssetPresets {
  /**
   * Key for the asset. Used in the assets endpoint.
   * @type {string}
   * @memberof SettingsStorageAssetPresets
   */
  key?: string
  /**
   * Whether to crop the thumbnail to match the size, or maintain the aspect ratio.
   * @type {string}
   * @memberof SettingsStorageAssetPresets
   */
  fit?: SettingsStorageAssetPresetsFitEnum
  /**
   * Width of the thumbnail.
   * @type {number}
   * @memberof SettingsStorageAssetPresets
   */
  width?: number
  /**
   * Height of the thumbnail.
   * @type {number}
   * @memberof SettingsStorageAssetPresets
   */
  height?: number
  /**
   * No image upscale
   * @type {boolean}
   * @memberof SettingsStorageAssetPresets
   */
  withoutEnlargement?: boolean
  /**
   * Quality of the compression used.
   * @type {number}
   * @memberof SettingsStorageAssetPresets
   */
  quality?: number
  /**
   * Reformat output image
   * @type {string}
   * @memberof SettingsStorageAssetPresets
   */
  format?: SettingsStorageAssetPresetsFormatEnum
  /**
   * Additional transformations to apply
   * @type {Array<SettingsTransforms>}
   * @memberof SettingsStorageAssetPresets
   */
  transforms?: Array<SettingsTransforms> | null
}

export const SettingsStorageAssetPresetsFitEnum = {
  Cover: 'cover',
  Contain: 'contain',
  Inside: 'inside',
  Outside: 'outside',
} as const

export type SettingsStorageAssetPresetsFitEnum =
  typeof SettingsStorageAssetPresetsFitEnum[keyof typeof SettingsStorageAssetPresetsFitEnum]
export const SettingsStorageAssetPresetsFormatEnum = {
  Empty: '',
  Jpeg: 'jpeg',
  Png: 'png',
  Webp: 'webp',
  Tiff: 'tiff',
} as const

export type SettingsStorageAssetPresetsFormatEnum =
  typeof SettingsStorageAssetPresetsFormatEnum[keyof typeof SettingsStorageAssetPresetsFormatEnum]

/**
 *
 * @export
 * @interface SettingsTransforms
 */
export interface SettingsTransforms {
  /**
   * The Sharp method name
   * @type {string}
   * @memberof SettingsTransforms
   */
  method?: string
  /**
   * A list of arguments to pass to the Sharp method
   * @type {Array<SettingsArguments>}
   * @memberof SettingsTransforms
   */
  arguments?: Array<SettingsArguments> | null
}
/**
 *
 * @export
 * @interface Users
 */
export interface Users {
  /**
   * Unique identifier for the user.
   * @type {string}
   * @memberof Users
   */
  id?: string
  /**
   * First name of the user.
   * @type {string}
   * @memberof Users
   */
  first_name?: string
  /**
   * Last name of the user.
   * @type {string}
   * @memberof Users
   */
  last_name?: string
  /**
   * Unique email address for the user.
   * @type {string}
   * @memberof Users
   */
  email?: string
  /**
   * Password of the user.
   * @type {string}
   * @memberof Users
   */
  password?: string
  /**
   * The user\'s location.
   * @type {string}
   * @memberof Users
   */
  location?: string | null
  /**
   * The user\'s title.
   * @type {string}
   * @memberof Users
   */
  title?: string | null
  /**
   * The user\'s description.
   * @type {string}
   * @memberof Users
   */
  description?: string | null
  /**
   * The user\'s tags.
   * @type {Array<string>}
   * @memberof Users
   */
  tags?: Array<string> | null
  /**
   * The user\'s avatar.
   * @type {string | Files}
   * @memberof Users
   */
  avatar?: string | Files | null
  /**
   * The user\'s language used in Directus.
   * @type {string}
   * @memberof Users
   */
  language?: string
  /**
   * What theme the user is using.
   * @type {string}
   * @memberof Users
   */
  theme?: UsersThemeEnum
  /**
   * The 2FA secret string that\'s used to generate one time passwords.
   * @type {string}
   * @memberof Users
   */
  tfa_secret?: string | null
  /**
   * Status of the user.
   * @type {string}
   * @memberof Users
   */
  status?: UsersStatusEnum
  /**
   * Unique identifier of the role of this user.
   * @type {string | Roles}
   * @memberof Users
   */
  role?: string | Roles
  /**
   * Static token for the user.
   * @type {string}
   * @memberof Users
   */
  token?: string | null
  /**
   *
   * @type {string}
   * @memberof Users
   */
  last_access?: string | null
  /**
   * Last page that the user was on.
   * @type {string}
   * @memberof Users
   */
  last_page?: string | null
  /**
   *
   * @type {string}
   * @memberof Users
   */
  provider?: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  external_identifier?: string | null
  /**
   *
   * @type {Array<string>}
   * @memberof Users
   */
  auth_data?: Array<string> | null
  /**
   *
   * @type {boolean}
   * @memberof Users
   */
  email_notifications?: boolean | null
  /**
   *
   * @type {string}
   * @memberof Users
   */
  preferences_divider?: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  admin_divider?: string
}

export const UsersThemeEnum = {
  Light: 'light',
  Dark: 'dark',
  Auto: 'auto',
} as const

export type UsersThemeEnum = typeof UsersThemeEnum[keyof typeof UsersThemeEnum]
export const UsersStatusEnum = {
  Active: 'active',
  Invited: 'invited',
  Draft: 'draft',
  Suspended: 'suspended',
  Deleted: 'deleted',
} as const

export type UsersStatusEnum =
  typeof UsersStatusEnum[keyof typeof UsersStatusEnum]

/**
 *
 * @export
 * @interface Webhooks
 */
export interface Webhooks {
  /**
   * The index of the webhook.
   * @type {number}
   * @memberof Webhooks
   */
  id?: number
  /**
   * The name of the webhook.
   * @type {string}
   * @memberof Webhooks
   */
  name?: string
  /**
   * Method used in the webhook.
   * @type {string}
   * @memberof Webhooks
   */
  method?: string
  /**
   * The url of the webhook.
   * @type {string}
   * @memberof Webhooks
   */
  url?: string | null
  /**
   * The status of the webhook.
   * @type {string}
   * @memberof Webhooks
   */
  status?: string
  /**
   * If yes, send the content of what was done
   * @type {boolean}
   * @memberof Webhooks
   */
  data?: boolean
  /**
   * The actions that triggers this webhook.
   * @type {Array<string>}
   * @memberof Webhooks
   */
  actions?: Array<string> | null
  /**
   *
   * @type {Array<string>}
   * @memberof Webhooks
   */
  collections?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof Webhooks
   */
  headers?: Array<string> | null
  /**
   *
   * @type {string}
   * @memberof Webhooks
   */
  triggers_divider?: string
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new comment.
     * @summary Create a Comment
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject5} [inlineObject5]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createComment: async (
      meta?: string,
      inlineObject5?: InlineObject5,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/activity/comment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject5,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing comment. Deleted comments can not be retrieved.
     * @summary Delete a Comment
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment: async (
      id: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteComment', 'id', id)
      const localVarPath = `/activity/comment/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of activity actions.
     * @summary List Activity Actions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivities: async (
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/activity`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information.
     * @summary Retrieve an Activity Action
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivity: async (
      id: number,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getActivity', 'id', id)
      const localVarPath = `/activity/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the content of an existing comment.
     * @summary Update a Comment
     * @param {number} id Index
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject6} [inlineObject6]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateComment: async (
      id: number,
      meta?: string,
      inlineObject6?: InlineObject6,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateComment', 'id', id)
      const localVarPath = `/activity/comment/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject6,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
  return {
    /**
     * Creates a new comment.
     * @summary Create a Comment
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject5} [inlineObject5]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createComment(
      meta?: string,
      inlineObject5?: InlineObject5,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20011>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(
        meta,
        inlineObject5,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing comment. Deleted comments can not be retrieved.
     * @summary Delete a Comment
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteComment(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a list of activity actions.
     * @summary List Activity Actions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActivities(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20010>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(
        fields,
        limit,
        meta,
        offset,
        sort,
        filter,
        search,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information.
     * @summary Retrieve an Activity Action
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActivity(
      id: number,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20011>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(
        id,
        fields,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update the content of an existing comment.
     * @summary Update a Comment
     * @param {number} id Index
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject6} [inlineObject6]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateComment(
      id: number,
      meta?: string,
      inlineObject6?: InlineObject6,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20011>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateComment(
        id,
        meta,
        inlineObject6,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ActivityApiFp(configuration)
  return {
    /**
     * Creates a new comment.
     * @summary Create a Comment
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject5} [inlineObject5]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createComment(
      meta?: string,
      inlineObject5?: InlineObject5,
      options?: any
    ): AxiosPromise<InlineResponse20011> {
      return localVarFp
        .createComment(meta, inlineObject5, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing comment. Deleted comments can not be retrieved.
     * @summary Delete a Comment
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteComment(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of activity actions.
     * @summary List Activity Actions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivities(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: any
    ): AxiosPromise<InlineResponse20010> {
      return localVarFp
        .getActivities(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information.
     * @summary Retrieve an Activity Action
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivity(
      id: number,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20011> {
      return localVarFp
        .getActivity(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the content of an existing comment.
     * @summary Update a Comment
     * @param {number} id Index
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject6} [inlineObject6]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateComment(
      id: number,
      meta?: string,
      inlineObject6?: InlineObject6,
      options?: any
    ): AxiosPromise<InlineResponse20011> {
      return localVarFp
        .updateComment(id, meta, inlineObject6, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
  /**
   * Creates a new comment.
   * @summary Create a Comment
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject5} [inlineObject5]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public createComment(
    meta?: string,
    inlineObject5?: InlineObject5,
    options?: AxiosRequestConfig
  ) {
    return ActivityApiFp(this.configuration)
      .createComment(meta, inlineObject5, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing comment. Deleted comments can not be retrieved.
   * @summary Delete a Comment
   * @param {number} id Index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public deleteComment(id: number, options?: AxiosRequestConfig) {
    return ActivityApiFp(this.configuration)
      .deleteComment(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of activity actions.
   * @summary List Activity Actions
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {string} [meta] What metadata to return in the response.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public getActivities(
    fields?: Array<string>,
    limit?: number,
    meta?: string,
    offset?: number,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return ActivityApiFp(this.configuration)
      .getActivities(fields, limit, meta, offset, sort, filter, search, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information.
   * @summary Retrieve an Activity Action
   * @param {number} id Index
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public getActivity(
    id: number,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return ActivityApiFp(this.configuration)
      .getActivity(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the content of an existing comment.
   * @summary Update a Comment
   * @param {number} id Index
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject6} [inlineObject6]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public updateComment(
    id: number,
    meta?: string,
    inlineObject6?: InlineObject6,
    options?: AxiosRequestConfig
  ) {
    return ActivityApiFp(this.configuration)
      .updateComment(id, meta, inlineObject6, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Image typed files can be dynamically resized and transformed to fit any need.
     * @summary Get an Asset
     * @param {string} id The id of the file.
     * @param {string} [key] The key of the asset size configured in settings.
     * @param {string} [transforms] A JSON array of image transformations
     * @param {boolean} [download] Download the asset to your computer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset: async (
      id: string,
      key?: string,
      transforms?: string,
      download?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAsset', 'id', id)
      const localVarPath = `/assets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (key !== undefined) {
        localVarQueryParameter['key'] = key
      }

      if (transforms !== undefined) {
        localVarQueryParameter['transforms'] = transforms
      }

      if (download !== undefined) {
        localVarQueryParameter['download'] = download
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
  return {
    /**
     * Image typed files can be dynamically resized and transformed to fit any need.
     * @summary Get an Asset
     * @param {string} id The id of the file.
     * @param {string} [key] The key of the asset size configured in settings.
     * @param {string} [transforms] A JSON array of image transformations
     * @param {boolean} [download] Download the asset to your computer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAsset(
      id: string,
      key?: string,
      transforms?: string,
      download?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(
        id,
        key,
        transforms,
        download,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AssetsApiFp(configuration)
  return {
    /**
     * Image typed files can be dynamically resized and transformed to fit any need.
     * @summary Get an Asset
     * @param {string} id The id of the file.
     * @param {string} [key] The key of the asset size configured in settings.
     * @param {string} [transforms] A JSON array of image transformations
     * @param {boolean} [download] Download the asset to your computer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset(
      id: string,
      key?: string,
      transforms?: string,
      download?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .getAsset(id, key, transforms, download, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
  /**
   * Image typed files can be dynamically resized and transformed to fit any need.
   * @summary Get an Asset
   * @param {string} id The id of the file.
   * @param {string} [key] The key of the asset size configured in settings.
   * @param {string} [transforms] A JSON array of image transformations
   * @param {boolean} [download] Download the asset to your computer
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getAsset(
    id: string,
    key?: string,
    transforms?: string,
    download?: boolean,
    options?: AxiosRequestConfig
  ) {
    return AssetsApiFp(this.configuration)
      .getAsset(id, key, transforms, download, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve a Temporary Access Token
     * @summary Retrieve a Temporary Access Token
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      inlineObject?: InlineObject,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Log Out
     * @summary Log Out
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (
      inlineObject2?: InlineObject2,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/logout`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject2,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List configured OAuth providers.
     * @summary List OAuth Providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/oauth`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start OAuth flow using the specified provider
     * @summary Authenticated using an OAuth provider
     * @param {string} provider Key of the activated OAuth provider.
     * @param {string} [redirect] Where to redirect on successful login.&lt;br/&gt;If set the authentication details are set inside cookies otherwise a JSON is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthProvider: async (
      provider: string,
      redirect?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'provider' is not null or undefined
      assertParamExists('oauthProvider', 'provider', provider)
      const localVarPath = `/auth/oauth/{provider}`.replace(
        `{${'provider'}}`,
        encodeURIComponent(String(provider))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (redirect !== undefined) {
        localVarQueryParameter['redirect'] = redirect
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Request a reset password email to be send.
     * @summary Request a Password Reset
     * @param {InlineObject3} [inlineObject3]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordRequest: async (
      inlineObject3?: InlineObject3,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/password/request`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject3,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
     * @summary Reset a Password
     * @param {InlineObject4} [inlineObject4]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordReset: async (
      inlineObject4?: InlineObject4,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/password/reset`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject4,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Refresh a Temporary Access Token.
     * @summary Refresh Token
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh: async (
      inlineObject1?: InlineObject1,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/refresh`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject1,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AuthenticationApiAxiosParamCreator(configuration)
  return {
    /**
     * Retrieve a Temporary Access Token
     * @summary Retrieve a Temporary Access Token
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      inlineObject?: InlineObject,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        inlineObject,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Log Out
     * @summary Log Out
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      inlineObject2?: InlineObject2,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(
        inlineObject2,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List configured OAuth providers.
     * @summary List OAuth Providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauth(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oauth(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Start OAuth flow using the specified provider
     * @summary Authenticated using an OAuth provider
     * @param {string} provider Key of the activated OAuth provider.
     * @param {string} [redirect] Where to redirect on successful login.&lt;br/&gt;If set the authentication details are set inside cookies otherwise a JSON is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauthProvider(
      provider: string,
      redirect?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2003>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProvider(
        provider,
        redirect,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Request a reset password email to be send.
     * @summary Request a Password Reset
     * @param {InlineObject3} [inlineObject3]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async passwordRequest(
      inlineObject3?: InlineObject3,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.passwordRequest(
        inlineObject3,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
     * @summary Reset a Password
     * @param {InlineObject4} [inlineObject4]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async passwordReset(
      inlineObject4?: InlineObject4,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.passwordReset(
        inlineObject4,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Refresh a Temporary Access Token.
     * @summary Refresh Token
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refresh(
      inlineObject1?: InlineObject1,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2001>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(
        inlineObject1,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthenticationApiFp(configuration)
  return {
    /**
     * Retrieve a Temporary Access Token
     * @summary Retrieve a Temporary Access Token
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      inlineObject?: InlineObject,
      options?: any
    ): AxiosPromise<InlineResponse200> {
      return localVarFp
        .login(inlineObject, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Log Out
     * @summary Log Out
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(inlineObject2?: InlineObject2, options?: any): AxiosPromise<void> {
      return localVarFp
        .logout(inlineObject2, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List configured OAuth providers.
     * @summary List OAuth Providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauth(options?: any): AxiosPromise<InlineResponse2002> {
      return localVarFp
        .oauth(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Start OAuth flow using the specified provider
     * @summary Authenticated using an OAuth provider
     * @param {string} provider Key of the activated OAuth provider.
     * @param {string} [redirect] Where to redirect on successful login.&lt;br/&gt;If set the authentication details are set inside cookies otherwise a JSON is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthProvider(
      provider: string,
      redirect?: string,
      options?: any
    ): AxiosPromise<InlineResponse2003> {
      return localVarFp
        .oauthProvider(provider, redirect, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Request a reset password email to be send.
     * @summary Request a Password Reset
     * @param {InlineObject3} [inlineObject3]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordRequest(
      inlineObject3?: InlineObject3,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .passwordRequest(inlineObject3, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
     * @summary Reset a Password
     * @param {InlineObject4} [inlineObject4]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordReset(
      inlineObject4?: InlineObject4,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .passwordReset(inlineObject4, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Refresh a Temporary Access Token.
     * @summary Refresh Token
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh(
      inlineObject1?: InlineObject1,
      options?: any
    ): AxiosPromise<InlineResponse2001> {
      return localVarFp
        .refresh(inlineObject1, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
  /**
   * Retrieve a Temporary Access Token
   * @summary Retrieve a Temporary Access Token
   * @param {InlineObject} [inlineObject]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public login(inlineObject?: InlineObject, options?: AxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .login(inlineObject, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Log Out
   * @summary Log Out
   * @param {InlineObject2} [inlineObject2]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public logout(inlineObject2?: InlineObject2, options?: AxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .logout(inlineObject2, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List configured OAuth providers.
   * @summary List OAuth Providers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public oauth(options?: AxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .oauth(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start OAuth flow using the specified provider
   * @summary Authenticated using an OAuth provider
   * @param {string} provider Key of the activated OAuth provider.
   * @param {string} [redirect] Where to redirect on successful login.&lt;br/&gt;If set the authentication details are set inside cookies otherwise a JSON is returned.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public oauthProvider(
    provider: string,
    redirect?: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationApiFp(this.configuration)
      .oauthProvider(provider, redirect, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Request a reset password email to be send.
   * @summary Request a Password Reset
   * @param {InlineObject3} [inlineObject3]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public passwordRequest(
    inlineObject3?: InlineObject3,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationApiFp(this.configuration)
      .passwordRequest(inlineObject3, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
   * @summary Reset a Password
   * @param {InlineObject4} [inlineObject4]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public passwordReset(
    inlineObject4?: InlineObject4,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationApiFp(this.configuration)
      .passwordReset(inlineObject4, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Refresh a Temporary Access Token.
   * @summary Refresh Token
   * @param {InlineObject1} [inlineObject1]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public refresh(inlineObject1?: InlineObject1, options?: AxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .refresh(inlineObject1, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new collection in Directus.
     * @summary Create a Collection
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject7} [inlineObject7]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection: async (
      meta?: string,
      inlineObject7?: InlineObject7,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/collections`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject7,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution.
     * @summary Delete a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteCollection', 'id', id)
      const localVarPath = `/collections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves the details of a single collection.
     * @summary Retrieve a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection: async (
      id: string,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCollection', 'id', id)
      const localVarPath = `/collections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of the collections available in the project.
     * @summary List Collections
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollections: async (
      offset?: number,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/collections`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing collection.
     * @summary Update a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject8} [inlineObject8]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollection: async (
      id: string,
      meta?: string,
      inlineObject8?: InlineObject8,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateCollection', 'id', id)
      const localVarPath = `/collections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject8,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CollectionsApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new collection in Directus.
     * @summary Create a Collection
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject7} [inlineObject7]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCollection(
      meta?: string,
      inlineObject7?: InlineObject7,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20013>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createCollection(
          meta,
          inlineObject7,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution.
     * @summary Delete a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCollection(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCollection(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieves the details of a single collection.
     * @summary Retrieve a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCollection(
      id: string,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20013>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(
        id,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a list of the collections available in the project.
     * @summary List Collections
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCollections(
      offset?: number,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20012>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCollections(
        offset,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing collection.
     * @summary Update a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject8} [inlineObject8]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCollection(
      id: string,
      meta?: string,
      inlineObject8?: InlineObject8,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20013>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateCollection(
          id,
          meta,
          inlineObject8,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CollectionsApiFp(configuration)
  return {
    /**
     * Create a new collection in Directus.
     * @summary Create a Collection
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject7} [inlineObject7]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(
      meta?: string,
      inlineObject7?: InlineObject7,
      options?: any
    ): AxiosPromise<InlineResponse20013> {
      return localVarFp
        .createCollection(meta, inlineObject7, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution.
     * @summary Delete a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteCollection(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves the details of a single collection.
     * @summary Retrieve a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(
      id: string,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20013> {
      return localVarFp
        .getCollection(id, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of the collections available in the project.
     * @summary List Collections
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollections(
      offset?: number,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20012> {
      return localVarFp
        .getCollections(offset, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing collection.
     * @summary Update a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject8} [inlineObject8]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollection(
      id: string,
      meta?: string,
      inlineObject8?: InlineObject8,
      options?: any
    ): AxiosPromise<InlineResponse20013> {
      return localVarFp
        .updateCollection(id, meta, inlineObject8, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
  /**
   * Create a new collection in Directus.
   * @summary Create a Collection
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject7} [inlineObject7]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public createCollection(
    meta?: string,
    inlineObject7?: InlineObject7,
    options?: AxiosRequestConfig
  ) {
    return CollectionsApiFp(this.configuration)
      .createCollection(meta, inlineObject7, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution.
   * @summary Delete a Collection
   * @param {string} id Unique identifier of the collection.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public deleteCollection(id: string, options?: AxiosRequestConfig) {
    return CollectionsApiFp(this.configuration)
      .deleteCollection(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves the details of a single collection.
   * @summary Retrieve a Collection
   * @param {string} id Unique identifier of the collection.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public getCollection(
    id: string,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return CollectionsApiFp(this.configuration)
      .getCollection(id, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of the collections available in the project.
   * @summary List Collections
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public getCollections(
    offset?: number,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return CollectionsApiFp(this.configuration)
      .getCollections(offset, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing collection.
   * @summary Update a Collection
   * @param {string} id Unique identifier of the collection.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject8} [inlineObject8]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public updateCollection(
    id: string,
    meta?: string,
    inlineObject8?: InlineObject8,
    options?: AxiosRequestConfig
  ) {
    return CollectionsApiFp(this.configuration)
      .updateCollection(id, meta, inlineObject8, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ExtensionsApi - axios parameter creator
 * @export
 */
export const ExtensionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * List all installed custom displays.
     * @summary List Displays
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDisplays: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/extensions/displays`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all installed custom interfaces.
     * @summary List Interfaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterfaces: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/extensions/interfaces`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all installed custom layouts.
     * @summary List Layouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLayouts: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/extensions/layouts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all installed custom modules.
     * @summary List Modules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getModules: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/extensions/modules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ExtensionsApi - functional programming interface
 * @export
 */
export const ExtensionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ExtensionsApiAxiosParamCreator(configuration)
  return {
    /**
     * List all installed custom displays.
     * @summary List Displays
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDisplays(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2004>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDisplays(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List all installed custom interfaces.
     * @summary List Interfaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInterfaces(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2004>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInterfaces(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List all installed custom layouts.
     * @summary List Layouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLayouts(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2004>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLayouts(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List all installed custom modules.
     * @summary List Modules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getModules(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2004>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getModules(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ExtensionsApi - factory interface
 * @export
 */
export const ExtensionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExtensionsApiFp(configuration)
  return {
    /**
     * List all installed custom displays.
     * @summary List Displays
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDisplays(options?: any): AxiosPromise<InlineResponse2004> {
      return localVarFp
        .getDisplays(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all installed custom interfaces.
     * @summary List Interfaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterfaces(options?: any): AxiosPromise<InlineResponse2004> {
      return localVarFp
        .getInterfaces(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all installed custom layouts.
     * @summary List Layouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLayouts(options?: any): AxiosPromise<InlineResponse2004> {
      return localVarFp
        .getLayouts(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all installed custom modules.
     * @summary List Modules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getModules(options?: any): AxiosPromise<InlineResponse2004> {
      return localVarFp
        .getModules(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ExtensionsApi - object-oriented interface
 * @export
 * @class ExtensionsApi
 * @extends {BaseAPI}
 */
export class ExtensionsApi extends BaseAPI {
  /**
   * List all installed custom displays.
   * @summary List Displays
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApi
   */
  public getDisplays(options?: AxiosRequestConfig) {
    return ExtensionsApiFp(this.configuration)
      .getDisplays(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List all installed custom interfaces.
   * @summary List Interfaces
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApi
   */
  public getInterfaces(options?: AxiosRequestConfig) {
    return ExtensionsApiFp(this.configuration)
      .getInterfaces(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List all installed custom layouts.
   * @summary List Layouts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApi
   */
  public getLayouts(options?: AxiosRequestConfig) {
    return ExtensionsApiFp(this.configuration)
      .getLayouts(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List all installed custom modules.
   * @summary List Modules
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExtensionsApi
   */
  public getModules(options?: AxiosRequestConfig) {
    return ExtensionsApiFp(this.configuration)
      .getModules(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FieldsApi - axios parameter creator
 * @export
 */
export const FieldsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new field in a given collection.
     * @summary Create Field in Collection
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {InlineObject9} [inlineObject9]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createField: async (
      collection: string,
      inlineObject9?: InlineObject9,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'collection' is not null or undefined
      assertParamExists('createField', 'collection', collection)
      const localVarPath = `/fields/{collection}`.replace(
        `{${'collection'}}`,
        encodeURIComponent(String(collection))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject9,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing field.
     * @summary Delete a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteField: async (
      collection: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'collection' is not null or undefined
      assertParamExists('deleteField', 'collection', collection)
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteField', 'id', id)
      const localVarPath = `/fields/{collection}/{id}`
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves the details of a single field in a given collection.
     * @summary Retrieve a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionField: async (
      collection: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'collection' is not null or undefined
      assertParamExists('getCollectionField', 'collection', collection)
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCollectionField', 'id', id)
      const localVarPath = `/fields/{collection}/{id}`
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of the fields available in the given collection.
     * @summary List Fields in Collection
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionFields: async (
      collection: string,
      sort?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'collection' is not null or undefined
      assertParamExists('getCollectionFields', 'collection', collection)
      const localVarPath = `/fields/{collection}`.replace(
        `{${'collection'}}`,
        encodeURIComponent(String(collection))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of the fields available in the project.
     * @summary List All Fields
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFields: async (
      limit?: number,
      sort?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/fields`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing field.
     * @summary Update a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {InlineObject10} [inlineObject10]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateField: async (
      collection: string,
      id: string,
      inlineObject10?: InlineObject10,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'collection' is not null or undefined
      assertParamExists('updateField', 'collection', collection)
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateField', 'id', id)
      const localVarPath = `/fields/{collection}/{id}`
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject10,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FieldsApi - functional programming interface
 * @export
 */
export const FieldsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FieldsApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new field in a given collection.
     * @summary Create Field in Collection
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {InlineObject9} [inlineObject9]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createField(
      collection: string,
      inlineObject9?: InlineObject9,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20015>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createField(
        collection,
        inlineObject9,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing field.
     * @summary Delete a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteField(
      collection: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteField(
        collection,
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieves the details of a single field in a given collection.
     * @summary Retrieve a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCollectionField(
      collection: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20015>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCollectionField(
          collection,
          id,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a list of the fields available in the given collection.
     * @summary List Fields in Collection
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCollectionFields(
      collection: string,
      sort?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20014>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCollectionFields(
          collection,
          sort,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Returns a list of the fields available in the project.
     * @summary List All Fields
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFields(
      limit?: number,
      sort?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20014>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFields(
        limit,
        sort,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing field.
     * @summary Update a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {InlineObject10} [inlineObject10]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateField(
      collection: string,
      id: string,
      inlineObject10?: InlineObject10,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20015>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateField(
        collection,
        id,
        inlineObject10,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * FieldsApi - factory interface
 * @export
 */
export const FieldsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FieldsApiFp(configuration)
  return {
    /**
     * Create a new field in a given collection.
     * @summary Create Field in Collection
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {InlineObject9} [inlineObject9]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createField(
      collection: string,
      inlineObject9?: InlineObject9,
      options?: any
    ): AxiosPromise<InlineResponse20015> {
      return localVarFp
        .createField(collection, inlineObject9, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing field.
     * @summary Delete a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteField(
      collection: string,
      id: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteField(collection, id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves the details of a single field in a given collection.
     * @summary Retrieve a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionField(
      collection: string,
      id: string,
      options?: any
    ): AxiosPromise<InlineResponse20015> {
      return localVarFp
        .getCollectionField(collection, id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of the fields available in the given collection.
     * @summary List Fields in Collection
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollectionFields(
      collection: string,
      sort?: Array<string>,
      options?: any
    ): AxiosPromise<InlineResponse20014> {
      return localVarFp
        .getCollectionFields(collection, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of the fields available in the project.
     * @summary List All Fields
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFields(
      limit?: number,
      sort?: Array<string>,
      options?: any
    ): AxiosPromise<InlineResponse20014> {
      return localVarFp
        .getFields(limit, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing field.
     * @summary Update a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {InlineObject10} [inlineObject10]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateField(
      collection: string,
      id: string,
      inlineObject10?: InlineObject10,
      options?: any
    ): AxiosPromise<InlineResponse20015> {
      return localVarFp
        .updateField(collection, id, inlineObject10, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FieldsApi - object-oriented interface
 * @export
 * @class FieldsApi
 * @extends {BaseAPI}
 */
export class FieldsApi extends BaseAPI {
  /**
   * Create a new field in a given collection.
   * @summary Create Field in Collection
   * @param {string} collection Unique identifier of the collection the item resides in.
   * @param {InlineObject9} [inlineObject9]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public createField(
    collection: string,
    inlineObject9?: InlineObject9,
    options?: AxiosRequestConfig
  ) {
    return FieldsApiFp(this.configuration)
      .createField(collection, inlineObject9, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing field.
   * @summary Delete a Field
   * @param {string} collection Unique identifier of the collection the item resides in.
   * @param {string} id Unique identifier of the field.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public deleteField(
    collection: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return FieldsApiFp(this.configuration)
      .deleteField(collection, id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves the details of a single field in a given collection.
   * @summary Retrieve a Field
   * @param {string} collection Unique identifier of the collection the item resides in.
   * @param {string} id Unique identifier of the field.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public getCollectionField(
    collection: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return FieldsApiFp(this.configuration)
      .getCollectionField(collection, id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of the fields available in the given collection.
   * @summary List Fields in Collection
   * @param {string} collection Unique identifier of the collection the item resides in.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public getCollectionFields(
    collection: string,
    sort?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return FieldsApiFp(this.configuration)
      .getCollectionFields(collection, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of the fields available in the project.
   * @summary List All Fields
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public getFields(
    limit?: number,
    sort?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return FieldsApiFp(this.configuration)
      .getFields(limit, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing field.
   * @summary Update a Field
   * @param {string} collection Unique identifier of the collection the item resides in.
   * @param {string} id Unique identifier of the field.
   * @param {InlineObject10} [inlineObject10]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FieldsApi
   */
  public updateField(
    collection: string,
    id: string,
    inlineObject10?: InlineObject10,
    options?: AxiosRequestConfig
  ) {
    return FieldsApiFp(this.configuration)
      .updateField(collection, id, inlineObject10, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new file
     * @summary Create a File
     * @param {InlineObject11} [inlineObject11]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile: async (
      inlineObject11?: InlineObject11,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/files`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject11,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing file.
     * @summary Delete a File
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFile', 'id', id)
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single file by unique identifier.
     * @summary Retrieve a Files
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: async (
      id: string,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFile', 'id', id)
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the files.
     * @summary List Files
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles: async (
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/files`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing file, and/or replace it\'s file contents.
     * @summary Update a File
     * @param {string} id Unique identifier for the object.
     * @param {any} file File contents.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {string} [title] Title for the file. Is extracted from the filename on upload, but can be edited by the user.
     * @param {string} [filenameDownload] Preferred filename when file is downloaded.
     * @param {string} [description] Description for the file.
     * @param {string | Folders} [folder] Virtual folder where this file resides in.
     * @param {Array<string>} [tags] Tags for the file. Is automatically populated based on EXIF data for images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile: async (
      id: string,
      file: any,
      fields?: Array<string>,
      meta?: string,
      title?: string,
      filenameDownload?: string,
      description?: string,
      folder?: string | Folders,
      tags?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateFile', 'id', id)
      // verify required parameter 'file' is not null or undefined
      assertParamExists('updateFile', 'file', file)
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (title !== undefined) {
        localVarFormParams.set('title', title as any)
      }

      if (filenameDownload !== undefined) {
        localVarFormParams.set('filename_download', filenameDownload as any)
      }

      if (description !== undefined) {
        localVarFormParams.set('description', description as any)
      }

      if (folder !== undefined) {
        localVarFormParams.set('folder', folder as any)
      }
      if (tags) {
        localVarFormParams.set('tags', tags.join(COLLECTION_FORMATS.csv))
      }

      if (file !== undefined) {
        localVarFormParams.set('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams.toString()

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new file
     * @summary Create a File
     * @param {InlineObject11} [inlineObject11]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFile(
      inlineObject11?: InlineObject11,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20017>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(
        inlineObject11,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing file.
     * @summary Delete a File
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single file by unique identifier.
     * @summary Retrieve a Files
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFile(
      id: string,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20017>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(
        id,
        fields,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the files.
     * @summary List Files
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFiles(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20016>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFiles(
        fields,
        limit,
        offset,
        sort,
        filter,
        search,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing file, and/or replace it\'s file contents.
     * @summary Update a File
     * @param {string} id Unique identifier for the object.
     * @param {any} file File contents.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {string} [title] Title for the file. Is extracted from the filename on upload, but can be edited by the user.
     * @param {string} [filenameDownload] Preferred filename when file is downloaded.
     * @param {string} [description] Description for the file.
     * @param {string | Folders} [folder] Virtual folder where this file resides in.
     * @param {Array<string>} [tags] Tags for the file. Is automatically populated based on EXIF data for images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFile(
      id: string,
      file: any,
      fields?: Array<string>,
      meta?: string,
      title?: string,
      filenameDownload?: string,
      description?: string,
      folder?: string | Folders,
      tags?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20017>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(
        id,
        file,
        fields,
        meta,
        title,
        filenameDownload,
        description,
        folder,
        tags,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FilesApiFp(configuration)
  return {
    /**
     * Create a new file
     * @summary Create a File
     * @param {InlineObject11} [inlineObject11]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile(
      inlineObject11?: InlineObject11,
      options?: any
    ): AxiosPromise<InlineResponse20017> {
      return localVarFp
        .createFile(inlineObject11, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing file.
     * @summary Delete a File
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteFile(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single file by unique identifier.
     * @summary Retrieve a Files
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(
      id: string,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20017> {
      return localVarFp
        .getFile(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the files.
     * @summary List Files
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20016> {
      return localVarFp
        .getFiles(fields, limit, offset, sort, filter, search, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing file, and/or replace it\'s file contents.
     * @summary Update a File
     * @param {string} id Unique identifier for the object.
     * @param {any} file File contents.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {string} [title] Title for the file. Is extracted from the filename on upload, but can be edited by the user.
     * @param {string} [filenameDownload] Preferred filename when file is downloaded.
     * @param {string} [description] Description for the file.
     * @param {string | Folders} [folder] Virtual folder where this file resides in.
     * @param {Array<string>} [tags] Tags for the file. Is automatically populated based on EXIF data for images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile(
      id: string,
      file: any,
      fields?: Array<string>,
      meta?: string,
      title?: string,
      filenameDownload?: string,
      description?: string,
      folder?: string | Folders,
      tags?: Array<string>,
      options?: any
    ): AxiosPromise<InlineResponse20017> {
      return localVarFp
        .updateFile(
          id,
          file,
          fields,
          meta,
          title,
          filenameDownload,
          description,
          folder,
          tags,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
  /**
   * Create a new file
   * @summary Create a File
   * @param {InlineObject11} [inlineObject11]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public createFile(
    inlineObject11?: InlineObject11,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .createFile(inlineObject11, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing file.
   * @summary Delete a File
   * @param {string} id Unique identifier for the object.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public deleteFile(id: string, options?: AxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .deleteFile(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single file by unique identifier.
   * @summary Retrieve a Files
   * @param {string} id Unique identifier for the object.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFile(
    id: string,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .getFile(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the files.
   * @summary List Files
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFiles(
    fields?: Array<string>,
    limit?: number,
    offset?: number,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .getFiles(fields, limit, offset, sort, filter, search, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing file, and/or replace it\'s file contents.
   * @summary Update a File
   * @param {string} id Unique identifier for the object.
   * @param {any} file File contents.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {string} [title] Title for the file. Is extracted from the filename on upload, but can be edited by the user.
   * @param {string} [filenameDownload] Preferred filename when file is downloaded.
   * @param {string} [description] Description for the file.
   * @param {string | Folders} [folder] Virtual folder where this file resides in.
   * @param {Array<string>} [tags] Tags for the file. Is automatically populated based on EXIF data for images.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public updateFile(
    id: string,
    file: any,
    fields?: Array<string>,
    meta?: string,
    title?: string,
    filenameDownload?: string,
    description?: string,
    folder?: string | Folders,
    tags?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .updateFile(
        id,
        file,
        fields,
        meta,
        title,
        filenameDownload,
        description,
        folder,
        tags,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new folder.
     * @summary Create a Folder
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject13} [inlineObject13]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder: async (
      fields?: Array<string>,
      meta?: string,
      inlineObject13?: InlineObject13,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/folders`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject13,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing folder
     * @summary Delete a Folder
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFolder: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFolder', 'id', id)
      const localVarPath = `/folders/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single folder by unique identifier.
     * @summary Retrieve a Folder
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolder: async (
      id: string,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFolder', 'id', id)
      const localVarPath = `/folders/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the folders.
     * @summary List Folders
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolders: async (
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/folders`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing folder
     * @summary Update a Folder
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject14} [inlineObject14]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFolder: async (
      id: string,
      fields?: Array<string>,
      meta?: string,
      inlineObject14?: InlineObject14,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateFolder', 'id', id)
      const localVarPath = `/folders/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject14,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new folder.
     * @summary Create a Folder
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject13} [inlineObject13]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFolder(
      fields?: Array<string>,
      meta?: string,
      inlineObject13?: InlineObject13,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20019>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(
        fields,
        meta,
        inlineObject13,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing folder
     * @summary Delete a Folder
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFolder(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single folder by unique identifier.
     * @summary Retrieve a Folder
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFolder(
      id: string,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20019>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(
        id,
        fields,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the folders.
     * @summary List Folders
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFolders(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20018>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFolders(
        fields,
        limit,
        offset,
        sort,
        filter,
        search,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing folder
     * @summary Update a Folder
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject14} [inlineObject14]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFolder(
      id: string,
      fields?: Array<string>,
      meta?: string,
      inlineObject14?: InlineObject14,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20019>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolder(
        id,
        fields,
        meta,
        inlineObject14,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FoldersApiFp(configuration)
  return {
    /**
     * Create a new folder.
     * @summary Create a Folder
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject13} [inlineObject13]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFolder(
      fields?: Array<string>,
      meta?: string,
      inlineObject13?: InlineObject13,
      options?: any
    ): AxiosPromise<InlineResponse20019> {
      return localVarFp
        .createFolder(fields, meta, inlineObject13, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing folder
     * @summary Delete a Folder
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFolder(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteFolder(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single folder by unique identifier.
     * @summary Retrieve a Folder
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolder(
      id: string,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20019> {
      return localVarFp
        .getFolder(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the folders.
     * @summary List Folders
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFolders(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20018> {
      return localVarFp
        .getFolders(fields, limit, offset, sort, filter, search, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing folder
     * @summary Update a Folder
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject14} [inlineObject14]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFolder(
      id: string,
      fields?: Array<string>,
      meta?: string,
      inlineObject14?: InlineObject14,
      options?: any
    ): AxiosPromise<InlineResponse20019> {
      return localVarFp
        .updateFolder(id, fields, meta, inlineObject14, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
  /**
   * Create a new folder.
   * @summary Create a Folder
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject13} [inlineObject13]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FoldersApi
   */
  public createFolder(
    fields?: Array<string>,
    meta?: string,
    inlineObject13?: InlineObject13,
    options?: AxiosRequestConfig
  ) {
    return FoldersApiFp(this.configuration)
      .createFolder(fields, meta, inlineObject13, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing folder
   * @summary Delete a Folder
   * @param {string} id Unique identifier for the object.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FoldersApi
   */
  public deleteFolder(id: string, options?: AxiosRequestConfig) {
    return FoldersApiFp(this.configuration)
      .deleteFolder(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single folder by unique identifier.
   * @summary Retrieve a Folder
   * @param {string} id Unique identifier for the object.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FoldersApi
   */
  public getFolder(
    id: string,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return FoldersApiFp(this.configuration)
      .getFolder(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the folders.
   * @summary List Folders
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FoldersApi
   */
  public getFolders(
    fields?: Array<string>,
    limit?: number,
    offset?: number,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return FoldersApiFp(this.configuration)
      .getFolders(fields, limit, offset, sort, filter, search, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing folder
   * @summary Update a Folder
   * @param {string} id Unique identifier for the object.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject14} [inlineObject14]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FoldersApi
   */
  public updateFolder(
    id: string,
    fields?: Array<string>,
    meta?: string,
    inlineObject14?: InlineObject14,
    options?: AxiosRequestConfig
  ) {
    return FoldersApiFp(this.configuration)
      .updateFolder(id, fields, meta, inlineObject14, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new Comment item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsComment> | ItemsComment} [arrayItemsCommentItemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsComment: async (
      meta?: string,
      arrayItemsCommentItemsComment?: Array<ItemsComment> | ItemsComment,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Comment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        arrayItemsCommentItemsComment,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new Post item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPost> | ItemsPost} [arrayItemsPostItemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsPost: async (
      meta?: string,
      arrayItemsPostItemsPost?: Array<ItemsPost> | ItemsPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Post`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        arrayItemsPostItemsPost,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new Post_files item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPostFiles> | ItemsPostFiles} [arrayItemsPostFilesItemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsPostFiles: async (
      meta?: string,
      arrayItemsPostFilesItemsPostFiles?:
        | Array<ItemsPostFiles>
        | ItemsPostFiles,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Post_files`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        arrayItemsPostFilesItemsPostFiles,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing Comment item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsComment: async (
      id: number | string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSingleItemsComment', 'id', id)
      const localVarPath = `/items/Comment/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing Post item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsPost: async (
      id: number | string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSingleItemsPost', 'id', id)
      const localVarPath = `/items/Post/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing Post_files item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsPostFiles: async (
      id: number | string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSingleItemsPostFiles', 'id', id)
      const localVarPath = `/items/Post_files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the Comment items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsComment: async (
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Comment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Auth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the Post items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsPost: async (
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Post`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Auth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the Post_files items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsPostFiles: async (
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Post_files`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Auth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single Comment item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsComment: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('readSingleItemsComment', 'id', id)
      const localVarPath = `/items/Comment/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single Post item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsPost: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('readSingleItemsPost', 'id', id)
      const localVarPath = `/items/Post/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single Post_files item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsPostFiles: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('readSingleItemsPostFiles', 'id', id)
      const localVarPath = `/items/Post_files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing Comment item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsComment} [itemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsComment: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsComment?: ItemsComment,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSingleItemsComment', 'id', id)
      const localVarPath = `/items/Comment/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemsComment,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing Post item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPost} [itemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsPost: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPost?: ItemsPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSingleItemsPost', 'id', id)
      const localVarPath = `/items/Post/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemsPost,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing Post_files item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPostFiles} [itemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsPostFiles: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPostFiles?: ItemsPostFiles,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSingleItemsPostFiles', 'id', id)
      const localVarPath = `/items/Post_files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemsPostFiles,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new Comment item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsComment> | ItemsComment} [arrayItemsCommentItemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createItemsComment(
      meta?: string,
      arrayItemsCommentItemsComment?: Array<ItemsComment> | ItemsComment,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createItemsComment(
          meta,
          arrayItemsCommentItemsComment,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Create a new Post item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPost> | ItemsPost} [arrayItemsPostItemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createItemsPost(
      meta?: string,
      arrayItemsPostItemsPost?: Array<ItemsPost> | ItemsPost,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsPost(
        meta,
        arrayItemsPostItemsPost,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Create a new Post_files item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPostFiles> | ItemsPostFiles} [arrayItemsPostFilesItemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createItemsPostFiles(
      meta?: string,
      arrayItemsPostFilesItemsPostFiles?:
        | Array<ItemsPostFiles>
        | ItemsPostFiles,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2009>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createItemsPostFiles(
          meta,
          arrayItemsPostFilesItemsPostFiles,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing Comment item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSingleItemsComment(
      id: number | string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSingleItemsComment(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing Post item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSingleItemsPost(
      id: number | string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSingleItemsPost(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing Post_files item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSingleItemsPostFiles(
      id: number | string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSingleItemsPostFiles(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the Comment items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readItemsComment(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readItemsComment(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the Post items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readItemsPost(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsPost(
        fields,
        limit,
        meta,
        offset,
        sort,
        filter,
        search,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the Post_files items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readItemsPostFiles(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2009>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readItemsPostFiles(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single Comment item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readSingleItemsComment(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readSingleItemsComment(
          id,
          fields,
          meta,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single Post item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readSingleItemsPost(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readSingleItemsPost(
          id,
          fields,
          meta,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single Post_files item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readSingleItemsPostFiles(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2009>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readSingleItemsPostFiles(
          id,
          fields,
          meta,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing Comment item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsComment} [itemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSingleItemsComment(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsComment?: ItemsComment,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSingleItemsComment(
          id,
          fields,
          meta,
          itemsComment,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing Post item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPost} [itemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSingleItemsPost(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPost?: ItemsPost,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSingleItemsPost(
          id,
          fields,
          meta,
          itemsPost,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing Post_files item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPostFiles} [itemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSingleItemsPostFiles(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPostFiles?: ItemsPostFiles,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2009>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSingleItemsPostFiles(
          id,
          fields,
          meta,
          itemsPostFiles,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ItemsApiFp(configuration)
  return {
    /**
     * Create a new Comment item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsComment> | ItemsComment} [arrayItemsCommentItemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsComment(
      meta?: string,
      arrayItemsCommentItemsComment?: Array<ItemsComment> | ItemsComment,
      options?: any
    ): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .createItemsComment(meta, arrayItemsCommentItemsComment, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new Post item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPost> | ItemsPost} [arrayItemsPostItemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsPost(
      meta?: string,
      arrayItemsPostItemsPost?: Array<ItemsPost> | ItemsPost,
      options?: any
    ): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .createItemsPost(meta, arrayItemsPostItemsPost, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new Post_files item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPostFiles> | ItemsPostFiles} [arrayItemsPostFilesItemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsPostFiles(
      meta?: string,
      arrayItemsPostFilesItemsPostFiles?:
        | Array<ItemsPostFiles>
        | ItemsPostFiles,
      options?: any
    ): AxiosPromise<InlineResponse2009> {
      return localVarFp
        .createItemsPostFiles(meta, arrayItemsPostFilesItemsPostFiles, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing Comment item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsComment(
      id: number | string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSingleItemsComment(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing Post item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsPost(
      id: number | string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSingleItemsPost(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing Post_files item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsPostFiles(
      id: number | string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSingleItemsPostFiles(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the Comment items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsComment(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: any
    ): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .readItemsComment(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * List the Post items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsPost(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: any
    ): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .readItemsPost(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * List the Post_files items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsPostFiles(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: any
    ): AxiosPromise<InlineResponse2009> {
      return localVarFp
        .readItemsPostFiles(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single Comment item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsComment(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .readSingleItemsComment(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single Post item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsPost(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .readSingleItemsPost(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single Post_files item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsPostFiles(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse2009> {
      return localVarFp
        .readSingleItemsPostFiles(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing Comment item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsComment} [itemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsComment(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsComment?: ItemsComment,
      options?: any
    ): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .updateSingleItemsComment(id, fields, meta, itemsComment, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing Post item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPost} [itemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsPost(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPost?: ItemsPost,
      options?: any
    ): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .updateSingleItemsPost(id, fields, meta, itemsPost, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing Post_files item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPostFiles} [itemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsPostFiles(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPostFiles?: ItemsPostFiles,
      options?: any
    ): AxiosPromise<InlineResponse2009> {
      return localVarFp
        .updateSingleItemsPostFiles(id, fields, meta, itemsPostFiles, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
  /**
   * Create a new Comment item.
   * @summary Create an Item
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<ItemsComment> | ItemsComment} [arrayItemsCommentItemsComment]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public createItemsComment(
    meta?: string,
    arrayItemsCommentItemsComment?: Array<ItemsComment> | ItemsComment,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .createItemsComment(meta, arrayItemsCommentItemsComment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new Post item.
   * @summary Create an Item
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<ItemsPost> | ItemsPost} [arrayItemsPostItemsPost]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public createItemsPost(
    meta?: string,
    arrayItemsPostItemsPost?: Array<ItemsPost> | ItemsPost,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .createItemsPost(meta, arrayItemsPostItemsPost, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new Post_files item.
   * @summary Create an Item
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<ItemsPostFiles> | ItemsPostFiles} [arrayItemsPostFilesItemsPostFiles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public createItemsPostFiles(
    meta?: string,
    arrayItemsPostFilesItemsPostFiles?: Array<ItemsPostFiles> | ItemsPostFiles,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .createItemsPostFiles(meta, arrayItemsPostFilesItemsPostFiles, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing Comment item.
   * @summary Delete an Item
   * @param {number | string} id Index of the item.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public deleteSingleItemsComment(
    id: number | string,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .deleteSingleItemsComment(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing Post item.
   * @summary Delete an Item
   * @param {number | string} id Index of the item.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public deleteSingleItemsPost(
    id: number | string,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .deleteSingleItemsPost(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing Post_files item.
   * @summary Delete an Item
   * @param {number | string} id Index of the item.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public deleteSingleItemsPostFiles(
    id: number | string,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .deleteSingleItemsPostFiles(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the Comment items.
   * @summary List Items
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {string} [meta] What metadata to return in the response.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public readItemsComment(
    fields?: Array<string>,
    limit?: number,
    meta?: string,
    offset?: number,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .readItemsComment(
        fields,
        limit,
        meta,
        offset,
        sort,
        filter,
        search,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the Post items.
   * @summary List Items
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {string} [meta] What metadata to return in the response.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public readItemsPost(
    fields?: Array<string>,
    limit?: number,
    meta?: string,
    offset?: number,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .readItemsPost(fields, limit, meta, offset, sort, filter, search, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the Post_files items.
   * @summary List Items
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {string} [meta] What metadata to return in the response.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public readItemsPostFiles(
    fields?: Array<string>,
    limit?: number,
    meta?: string,
    offset?: number,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .readItemsPostFiles(
        fields,
        limit,
        meta,
        offset,
        sort,
        filter,
        search,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single Comment item by unique identifier.
   * @summary Retrieve an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public readSingleItemsComment(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .readSingleItemsComment(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single Post item by unique identifier.
   * @summary Retrieve an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public readSingleItemsPost(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .readSingleItemsPost(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single Post_files item by unique identifier.
   * @summary Retrieve an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public readSingleItemsPostFiles(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .readSingleItemsPostFiles(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing Comment item.
   * @summary Update an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {ItemsComment} [itemsComment]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public updateSingleItemsComment(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    itemsComment?: ItemsComment,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .updateSingleItemsComment(id, fields, meta, itemsComment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing Post item.
   * @summary Update an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {ItemsPost} [itemsPost]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public updateSingleItemsPost(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    itemsPost?: ItemsPost,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .updateSingleItemsPost(id, fields, meta, itemsPost, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing Post_files item.
   * @summary Update an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {ItemsPostFiles} [itemsPostFiles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsApi
   */
  public updateSingleItemsPostFiles(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    itemsPostFiles?: ItemsPostFiles,
    options?: AxiosRequestConfig
  ) {
    return ItemsApiFp(this.configuration)
      .updateSingleItemsPostFiles(id, fields, meta, itemsPostFiles, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ItemsCommentApi - axios parameter creator
 * @export
 */
export const ItemsCommentApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new Comment item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsComment> | ItemsComment} [arrayItemsCommentItemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsComment: async (
      meta?: string,
      arrayItemsCommentItemsComment?: Array<ItemsComment> | ItemsComment,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Comment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        arrayItemsCommentItemsComment,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing Comment item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsComment: async (
      id: number | string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSingleItemsComment', 'id', id)
      const localVarPath = `/items/Comment/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the Comment items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsComment: async (
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Comment`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Auth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single Comment item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsComment: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('readSingleItemsComment', 'id', id)
      const localVarPath = `/items/Comment/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing Comment item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsComment} [itemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsComment: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsComment?: ItemsComment,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSingleItemsComment', 'id', id)
      const localVarPath = `/items/Comment/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemsComment,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ItemsCommentApi - functional programming interface
 * @export
 */
export const ItemsCommentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ItemsCommentApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new Comment item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsComment> | ItemsComment} [arrayItemsCommentItemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createItemsComment(
      meta?: string,
      arrayItemsCommentItemsComment?: Array<ItemsComment> | ItemsComment,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createItemsComment(
          meta,
          arrayItemsCommentItemsComment,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing Comment item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSingleItemsComment(
      id: number | string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSingleItemsComment(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the Comment items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readItemsComment(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readItemsComment(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single Comment item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readSingleItemsComment(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readSingleItemsComment(
          id,
          fields,
          meta,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing Comment item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsComment} [itemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSingleItemsComment(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsComment?: ItemsComment,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSingleItemsComment(
          id,
          fields,
          meta,
          itemsComment,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ItemsCommentApi - factory interface
 * @export
 */
export const ItemsCommentApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ItemsCommentApiFp(configuration)
  return {
    /**
     * Create a new Comment item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsComment> | ItemsComment} [arrayItemsCommentItemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsComment(
      meta?: string,
      arrayItemsCommentItemsComment?: Array<ItemsComment> | ItemsComment,
      options?: any
    ): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .createItemsComment(meta, arrayItemsCommentItemsComment, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing Comment item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsComment(
      id: number | string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSingleItemsComment(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the Comment items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsComment(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: any
    ): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .readItemsComment(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single Comment item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsComment(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .readSingleItemsComment(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing Comment item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsComment} [itemsComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsComment(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsComment?: ItemsComment,
      options?: any
    ): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .updateSingleItemsComment(id, fields, meta, itemsComment, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ItemsCommentApi - object-oriented interface
 * @export
 * @class ItemsCommentApi
 * @extends {BaseAPI}
 */
export class ItemsCommentApi extends BaseAPI {
  /**
   * Create a new Comment item.
   * @summary Create an Item
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<ItemsComment> | ItemsComment} [arrayItemsCommentItemsComment]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsCommentApi
   */
  public createItemsComment(
    meta?: string,
    arrayItemsCommentItemsComment?: Array<ItemsComment> | ItemsComment,
    options?: AxiosRequestConfig
  ) {
    return ItemsCommentApiFp(this.configuration)
      .createItemsComment(meta, arrayItemsCommentItemsComment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing Comment item.
   * @summary Delete an Item
   * @param {number | string} id Index of the item.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsCommentApi
   */
  public deleteSingleItemsComment(
    id: number | string,
    options?: AxiosRequestConfig
  ) {
    return ItemsCommentApiFp(this.configuration)
      .deleteSingleItemsComment(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the Comment items.
   * @summary List Items
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {string} [meta] What metadata to return in the response.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsCommentApi
   */
  public readItemsComment(
    fields?: Array<string>,
    limit?: number,
    meta?: string,
    offset?: number,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsCommentApiFp(this.configuration)
      .readItemsComment(
        fields,
        limit,
        meta,
        offset,
        sort,
        filter,
        search,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single Comment item by unique identifier.
   * @summary Retrieve an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsCommentApi
   */
  public readSingleItemsComment(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsCommentApiFp(this.configuration)
      .readSingleItemsComment(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing Comment item.
   * @summary Update an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {ItemsComment} [itemsComment]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsCommentApi
   */
  public updateSingleItemsComment(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    itemsComment?: ItemsComment,
    options?: AxiosRequestConfig
  ) {
    return ItemsCommentApiFp(this.configuration)
      .updateSingleItemsComment(id, fields, meta, itemsComment, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ItemsPostApi - axios parameter creator
 * @export
 */
export const ItemsPostApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new Post item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPost> | ItemsPost} [arrayItemsPostItemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsPost: async (
      meta?: string,
      arrayItemsPostItemsPost?: Array<ItemsPost> | ItemsPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Post`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        arrayItemsPostItemsPost,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing Post item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsPost: async (
      id: number | string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSingleItemsPost', 'id', id)
      const localVarPath = `/items/Post/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the Post items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsPost: async (
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Post`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Auth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single Post item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsPost: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('readSingleItemsPost', 'id', id)
      const localVarPath = `/items/Post/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing Post item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPost} [itemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsPost: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPost?: ItemsPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSingleItemsPost', 'id', id)
      const localVarPath = `/items/Post/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemsPost,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ItemsPostApi - functional programming interface
 * @export
 */
export const ItemsPostApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ItemsPostApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new Post item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPost> | ItemsPost} [arrayItemsPostItemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createItemsPost(
      meta?: string,
      arrayItemsPostItemsPost?: Array<ItemsPost> | ItemsPost,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsPost(
        meta,
        arrayItemsPostItemsPost,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing Post item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSingleItemsPost(
      id: number | string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSingleItemsPost(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the Post items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readItemsPost(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsPost(
        fields,
        limit,
        meta,
        offset,
        sort,
        filter,
        search,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single Post item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readSingleItemsPost(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readSingleItemsPost(
          id,
          fields,
          meta,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing Post item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPost} [itemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSingleItemsPost(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPost?: ItemsPost,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSingleItemsPost(
          id,
          fields,
          meta,
          itemsPost,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ItemsPostApi - factory interface
 * @export
 */
export const ItemsPostApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ItemsPostApiFp(configuration)
  return {
    /**
     * Create a new Post item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPost> | ItemsPost} [arrayItemsPostItemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsPost(
      meta?: string,
      arrayItemsPostItemsPost?: Array<ItemsPost> | ItemsPost,
      options?: any
    ): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .createItemsPost(meta, arrayItemsPostItemsPost, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing Post item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsPost(
      id: number | string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSingleItemsPost(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the Post items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsPost(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: any
    ): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .readItemsPost(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single Post item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsPost(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .readSingleItemsPost(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing Post item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPost} [itemsPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsPost(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPost?: ItemsPost,
      options?: any
    ): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .updateSingleItemsPost(id, fields, meta, itemsPost, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ItemsPostApi - object-oriented interface
 * @export
 * @class ItemsPostApi
 * @extends {BaseAPI}
 */
export class ItemsPostApi extends BaseAPI {
  /**
   * Create a new Post item.
   * @summary Create an Item
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<ItemsPost> | ItemsPost} [arrayItemsPostItemsPost]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsPostApi
   */
  public createItemsPost(
    meta?: string,
    arrayItemsPostItemsPost?: Array<ItemsPost> | ItemsPost,
    options?: AxiosRequestConfig
  ) {
    return ItemsPostApiFp(this.configuration)
      .createItemsPost(meta, arrayItemsPostItemsPost, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing Post item.
   * @summary Delete an Item
   * @param {number | string} id Index of the item.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsPostApi
   */
  public deleteSingleItemsPost(
    id: number | string,
    options?: AxiosRequestConfig
  ) {
    return ItemsPostApiFp(this.configuration)
      .deleteSingleItemsPost(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the Post items.
   * @summary List Items
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {string} [meta] What metadata to return in the response.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsPostApi
   */
  public readItemsPost(
    fields?: Array<string>,
    limit?: number,
    meta?: string,
    offset?: number,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsPostApiFp(this.configuration)
      .readItemsPost(fields, limit, meta, offset, sort, filter, search, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single Post item by unique identifier.
   * @summary Retrieve an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsPostApi
   */
  public readSingleItemsPost(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsPostApiFp(this.configuration)
      .readSingleItemsPost(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing Post item.
   * @summary Update an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {ItemsPost} [itemsPost]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsPostApi
   */
  public updateSingleItemsPost(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    itemsPost?: ItemsPost,
    options?: AxiosRequestConfig
  ) {
    return ItemsPostApiFp(this.configuration)
      .updateSingleItemsPost(id, fields, meta, itemsPost, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ItemsPostFilesApi - axios parameter creator
 * @export
 */
export const ItemsPostFilesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new Post_files item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPostFiles> | ItemsPostFiles} [arrayItemsPostFilesItemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsPostFiles: async (
      meta?: string,
      arrayItemsPostFilesItemsPostFiles?:
        | Array<ItemsPostFiles>
        | ItemsPostFiles,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Post_files`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        arrayItemsPostFilesItemsPostFiles,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing Post_files item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsPostFiles: async (
      id: number | string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSingleItemsPostFiles', 'id', id)
      const localVarPath = `/items/Post_files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the Post_files items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsPostFiles: async (
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/Post_files`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Auth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single Post_files item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsPostFiles: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('readSingleItemsPostFiles', 'id', id)
      const localVarPath = `/items/Post_files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing Post_files item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPostFiles} [itemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsPostFiles: async (
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPostFiles?: ItemsPostFiles,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSingleItemsPostFiles', 'id', id)
      const localVarPath = `/items/Post_files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        itemsPostFiles,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ItemsPostFilesApi - functional programming interface
 * @export
 */
export const ItemsPostFilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ItemsPostFilesApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new Post_files item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPostFiles> | ItemsPostFiles} [arrayItemsPostFilesItemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createItemsPostFiles(
      meta?: string,
      arrayItemsPostFilesItemsPostFiles?:
        | Array<ItemsPostFiles>
        | ItemsPostFiles,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2009>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createItemsPostFiles(
          meta,
          arrayItemsPostFilesItemsPostFiles,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing Post_files item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSingleItemsPostFiles(
      id: number | string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSingleItemsPostFiles(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the Post_files items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readItemsPostFiles(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2009>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readItemsPostFiles(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single Post_files item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readSingleItemsPostFiles(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2009>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readSingleItemsPostFiles(
          id,
          fields,
          meta,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing Post_files item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPostFiles} [itemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSingleItemsPostFiles(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPostFiles?: ItemsPostFiles,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2009>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSingleItemsPostFiles(
          id,
          fields,
          meta,
          itemsPostFiles,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ItemsPostFilesApi - factory interface
 * @export
 */
export const ItemsPostFilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ItemsPostFilesApiFp(configuration)
  return {
    /**
     * Create a new Post_files item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<ItemsPostFiles> | ItemsPostFiles} [arrayItemsPostFilesItemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createItemsPostFiles(
      meta?: string,
      arrayItemsPostFilesItemsPostFiles?:
        | Array<ItemsPostFiles>
        | ItemsPostFiles,
      options?: any
    ): AxiosPromise<InlineResponse2009> {
      return localVarFp
        .createItemsPostFiles(meta, arrayItemsPostFilesItemsPostFiles, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing Post_files item.
     * @summary Delete an Item
     * @param {number | string} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSingleItemsPostFiles(
      id: number | string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSingleItemsPostFiles(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the Post_files items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readItemsPostFiles(
      fields?: Array<string>,
      limit?: number,
      meta?: string,
      offset?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: any
    ): AxiosPromise<InlineResponse2009> {
      return localVarFp
        .readItemsPostFiles(
          fields,
          limit,
          meta,
          offset,
          sort,
          filter,
          search,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single Post_files item by unique identifier.
     * @summary Retrieve an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSingleItemsPostFiles(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse2009> {
      return localVarFp
        .readSingleItemsPostFiles(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing Post_files item.
     * @summary Update an Item
     * @param {number | string} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsPostFiles} [itemsPostFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSingleItemsPostFiles(
      id: number | string,
      fields?: Array<string>,
      meta?: string,
      itemsPostFiles?: ItemsPostFiles,
      options?: any
    ): AxiosPromise<InlineResponse2009> {
      return localVarFp
        .updateSingleItemsPostFiles(id, fields, meta, itemsPostFiles, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ItemsPostFilesApi - object-oriented interface
 * @export
 * @class ItemsPostFilesApi
 * @extends {BaseAPI}
 */
export class ItemsPostFilesApi extends BaseAPI {
  /**
   * Create a new Post_files item.
   * @summary Create an Item
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<ItemsPostFiles> | ItemsPostFiles} [arrayItemsPostFilesItemsPostFiles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsPostFilesApi
   */
  public createItemsPostFiles(
    meta?: string,
    arrayItemsPostFilesItemsPostFiles?: Array<ItemsPostFiles> | ItemsPostFiles,
    options?: AxiosRequestConfig
  ) {
    return ItemsPostFilesApiFp(this.configuration)
      .createItemsPostFiles(meta, arrayItemsPostFilesItemsPostFiles, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing Post_files item.
   * @summary Delete an Item
   * @param {number | string} id Index of the item.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsPostFilesApi
   */
  public deleteSingleItemsPostFiles(
    id: number | string,
    options?: AxiosRequestConfig
  ) {
    return ItemsPostFilesApiFp(this.configuration)
      .deleteSingleItemsPostFiles(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the Post_files items.
   * @summary List Items
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {string} [meta] What metadata to return in the response.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsPostFilesApi
   */
  public readItemsPostFiles(
    fields?: Array<string>,
    limit?: number,
    meta?: string,
    offset?: number,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsPostFilesApiFp(this.configuration)
      .readItemsPostFiles(
        fields,
        limit,
        meta,
        offset,
        sort,
        filter,
        search,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single Post_files item by unique identifier.
   * @summary Retrieve an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsPostFilesApi
   */
  public readSingleItemsPostFiles(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return ItemsPostFilesApiFp(this.configuration)
      .readSingleItemsPostFiles(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing Post_files item.
   * @summary Update an Item
   * @param {number | string} id Index of the item.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {ItemsPostFiles} [itemsPostFiles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemsPostFilesApi
   */
  public updateSingleItemsPostFiles(
    id: number | string,
    fields?: Array<string>,
    meta?: string,
    itemsPostFiles?: ItemsPostFiles,
    options?: AxiosRequestConfig
  ) {
    return ItemsPostFilesApiFp(this.configuration)
      .updateSingleItemsPostFiles(id, fields, meta, itemsPostFiles, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new permission.
     * @summary Create a Permission
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject15} [inlineObject15]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPermission: async (
      meta?: string,
      inlineObject15?: InlineObject15,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/permissions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject15,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing permission
     * @summary Delete a Permission
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePermission: async (
      id: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deletePermission', 'id', id)
      const localVarPath = `/permissions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the permissions that apply to the current user.
     * @summary List My Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyPermissions: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/permissions/me`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single permissions object by unique identifier.
     * @summary Retrieve a Permission
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermission: async (
      id: number,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPermission', 'id', id)
      const localVarPath = `/permissions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all permissions.
     * @summary List Permissions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissions: async (
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/permissions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing permission
     * @summary Update a Permission
     * @param {number} id Index
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject16} [inlineObject16]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePermission: async (
      id: number,
      meta?: string,
      inlineObject16?: InlineObject16,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updatePermission', 'id', id)
      const localVarPath = `/permissions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject16,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PermissionsApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new permission.
     * @summary Create a Permission
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject15} [inlineObject15]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPermission(
      meta?: string,
      inlineObject15?: InlineObject15,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20021>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPermission(
          meta,
          inlineObject15,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing permission
     * @summary Delete a Permission
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePermission(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePermission(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the permissions that apply to the current user.
     * @summary List My Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyPermissions(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20020>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMyPermissions(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single permissions object by unique identifier.
     * @summary Retrieve a Permission
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPermission(
      id: number,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20021>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPermission(
        id,
        fields,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List all permissions.
     * @summary List Permissions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPermissions(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20020>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissions(
        fields,
        limit,
        offset,
        meta,
        sort,
        filter,
        search,
        page,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing permission
     * @summary Update a Permission
     * @param {number} id Index
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject16} [inlineObject16]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePermission(
      id: number,
      meta?: string,
      inlineObject16?: InlineObject16,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20021>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePermission(
          id,
          meta,
          inlineObject16,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PermissionsApiFp(configuration)
  return {
    /**
     * Create a new permission.
     * @summary Create a Permission
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject15} [inlineObject15]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPermission(
      meta?: string,
      inlineObject15?: InlineObject15,
      options?: any
    ): AxiosPromise<InlineResponse20021> {
      return localVarFp
        .createPermission(meta, inlineObject15, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing permission
     * @summary Delete a Permission
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePermission(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .deletePermission(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the permissions that apply to the current user.
     * @summary List My Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyPermissions(options?: any): AxiosPromise<InlineResponse20020> {
      return localVarFp
        .getMyPermissions(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single permissions object by unique identifier.
     * @summary Retrieve a Permission
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermission(
      id: number,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20021> {
      return localVarFp
        .getPermission(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all permissions.
     * @summary List Permissions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissions(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options?: any
    ): AxiosPromise<InlineResponse20020> {
      return localVarFp
        .getPermissions(
          fields,
          limit,
          offset,
          meta,
          sort,
          filter,
          search,
          page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing permission
     * @summary Update a Permission
     * @param {number} id Index
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject16} [inlineObject16]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePermission(
      id: number,
      meta?: string,
      inlineObject16?: InlineObject16,
      options?: any
    ): AxiosPromise<InlineResponse20021> {
      return localVarFp
        .updatePermission(id, meta, inlineObject16, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
  /**
   * Create a new permission.
   * @summary Create a Permission
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject15} [inlineObject15]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PermissionsApi
   */
  public createPermission(
    meta?: string,
    inlineObject15?: InlineObject15,
    options?: AxiosRequestConfig
  ) {
    return PermissionsApiFp(this.configuration)
      .createPermission(meta, inlineObject15, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing permission
   * @summary Delete a Permission
   * @param {number} id Index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PermissionsApi
   */
  public deletePermission(id: number, options?: AxiosRequestConfig) {
    return PermissionsApiFp(this.configuration)
      .deletePermission(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the permissions that apply to the current user.
   * @summary List My Permissions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PermissionsApi
   */
  public getMyPermissions(options?: AxiosRequestConfig) {
    return PermissionsApiFp(this.configuration)
      .getMyPermissions(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single permissions object by unique identifier.
   * @summary Retrieve a Permission
   * @param {number} id Index
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PermissionsApi
   */
  public getPermission(
    id: number,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return PermissionsApiFp(this.configuration)
      .getPermission(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List all permissions.
   * @summary List Permissions
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PermissionsApi
   */
  public getPermissions(
    fields?: Array<string>,
    limit?: number,
    offset?: number,
    meta?: string,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return PermissionsApiFp(this.configuration)
      .getPermissions(
        fields,
        limit,
        offset,
        meta,
        sort,
        filter,
        search,
        page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing permission
   * @summary Update a Permission
   * @param {number} id Index
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject16} [inlineObject16]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PermissionsApi
   */
  public updatePermission(
    id: number,
    meta?: string,
    inlineObject16?: InlineObject16,
    options?: AxiosRequestConfig
  ) {
    return PermissionsApiFp(this.configuration)
      .updatePermission(id, meta, inlineObject16, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PresetsApi - axios parameter creator
 * @export
 */
export const PresetsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new preset.
     * @summary Create a Preset
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPreset: async (
      fields?: Array<string>,
      meta?: string,
      inlineObject17?: InlineObject17,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/presets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject17,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing preset.
     * @summary Delete a Preset
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePreset: async (
      id: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deletePreset', 'id', id)
      const localVarPath = `/presets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Auth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single preset by unique identifier.
     * @summary Retrieve a Preset
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPreset: async (
      id: number,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPreset', 'id', id)
      const localVarPath = `/presets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Auth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the presets.
     * @summary List Presets
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPresets: async (
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      page?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/presets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Auth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration
      )

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing preset.
     * @summary Update a Preset
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePreset: async (
      id: number,
      fields?: Array<string>,
      meta?: string,
      inlineObject18?: InlineObject18,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updatePreset', 'id', id)
      const localVarPath = `/presets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject18,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PresetsApi - functional programming interface
 * @export
 */
export const PresetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PresetsApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new preset.
     * @summary Create a Preset
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPreset(
      fields?: Array<string>,
      meta?: string,
      inlineObject17?: InlineObject17,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20023>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPreset(
        fields,
        meta,
        inlineObject17,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing preset.
     * @summary Delete a Preset
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePreset(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePreset(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single preset by unique identifier.
     * @summary Retrieve a Preset
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPreset(
      id: number,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20023>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPreset(
        id,
        fields,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the presets.
     * @summary List Presets
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPresets(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      page?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20022>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPresets(
        fields,
        limit,
        offset,
        page,
        sort,
        filter,
        search,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing preset.
     * @summary Update a Preset
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePreset(
      id: number,
      fields?: Array<string>,
      meta?: string,
      inlineObject18?: InlineObject18,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20023>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePreset(
        id,
        fields,
        meta,
        inlineObject18,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * PresetsApi - factory interface
 * @export
 */
export const PresetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PresetsApiFp(configuration)
  return {
    /**
     * Create a new preset.
     * @summary Create a Preset
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPreset(
      fields?: Array<string>,
      meta?: string,
      inlineObject17?: InlineObject17,
      options?: any
    ): AxiosPromise<InlineResponse20023> {
      return localVarFp
        .createPreset(fields, meta, inlineObject17, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing preset.
     * @summary Delete a Preset
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePreset(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .deletePreset(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single preset by unique identifier.
     * @summary Retrieve a Preset
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPreset(
      id: number,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20023> {
      return localVarFp
        .getPreset(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the presets.
     * @summary List Presets
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPresets(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      page?: number,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20022> {
      return localVarFp
        .getPresets(
          fields,
          limit,
          offset,
          page,
          sort,
          filter,
          search,
          meta,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing preset.
     * @summary Update a Preset
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePreset(
      id: number,
      fields?: Array<string>,
      meta?: string,
      inlineObject18?: InlineObject18,
      options?: any
    ): AxiosPromise<InlineResponse20023> {
      return localVarFp
        .updatePreset(id, fields, meta, inlineObject18, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PresetsApi - object-oriented interface
 * @export
 * @class PresetsApi
 * @extends {BaseAPI}
 */
export class PresetsApi extends BaseAPI {
  /**
   * Create a new preset.
   * @summary Create a Preset
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject17} [inlineObject17]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PresetsApi
   */
  public createPreset(
    fields?: Array<string>,
    meta?: string,
    inlineObject17?: InlineObject17,
    options?: AxiosRequestConfig
  ) {
    return PresetsApiFp(this.configuration)
      .createPreset(fields, meta, inlineObject17, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing preset.
   * @summary Delete a Preset
   * @param {number} id Index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PresetsApi
   */
  public deletePreset(id: number, options?: AxiosRequestConfig) {
    return PresetsApiFp(this.configuration)
      .deletePreset(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single preset by unique identifier.
   * @summary Retrieve a Preset
   * @param {number} id Index
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PresetsApi
   */
  public getPreset(
    id: number,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return PresetsApiFp(this.configuration)
      .getPreset(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the presets.
   * @summary List Presets
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PresetsApi
   */
  public getPresets(
    fields?: Array<string>,
    limit?: number,
    offset?: number,
    page?: number,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return PresetsApiFp(this.configuration)
      .getPresets(
        fields,
        limit,
        offset,
        page,
        sort,
        filter,
        search,
        meta,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing preset.
   * @summary Update a Preset
   * @param {number} id Index
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject18} [inlineObject18]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PresetsApi
   */
  public updatePreset(
    id: number,
    fields?: Array<string>,
    meta?: string,
    inlineObject18?: InlineObject18,
    options?: AxiosRequestConfig
  ) {
    return PresetsApiFp(this.configuration)
      .updatePreset(id, fields, meta, inlineObject18, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RelationsApi - axios parameter creator
 * @export
 */
export const RelationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new relation.
     * @summary Create a Relation
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRelation: async (
      fields?: Array<string>,
      meta?: string,
      inlineObject19?: InlineObject19,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/relations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject19,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing relation.
     * @summary Delete a Relation
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRelation: async (
      id: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteRelation', 'id', id)
      const localVarPath = `/relations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single relation by unique identifier.
     * @summary Retrieve a Relation
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelation: async (
      id: number,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getRelation', 'id', id)
      const localVarPath = `/relations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the relations.
     * @summary List Relations
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelations: async (
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/relations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing relation
     * @summary Update a Relation
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRelation: async (
      id: number,
      fields?: Array<string>,
      meta?: string,
      inlineObject20?: InlineObject20,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateRelation', 'id', id)
      const localVarPath = `/relations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject20,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RelationsApi - functional programming interface
 * @export
 */
export const RelationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RelationsApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new relation.
     * @summary Create a Relation
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRelation(
      fields?: Array<string>,
      meta?: string,
      inlineObject19?: InlineObject19,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20025>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRelation(
        fields,
        meta,
        inlineObject19,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing relation.
     * @summary Delete a Relation
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRelation(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelation(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single relation by unique identifier.
     * @summary Retrieve a Relation
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRelation(
      id: number,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20025>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRelation(
        id,
        fields,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the relations.
     * @summary List Relations
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRelations(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20024>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRelations(
        fields,
        limit,
        offset,
        meta,
        sort,
        filter,
        search,
        page,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing relation
     * @summary Update a Relation
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRelation(
      id: number,
      fields?: Array<string>,
      meta?: string,
      inlineObject20?: InlineObject20,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20025>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRelation(
        id,
        fields,
        meta,
        inlineObject20,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * RelationsApi - factory interface
 * @export
 */
export const RelationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RelationsApiFp(configuration)
  return {
    /**
     * Create a new relation.
     * @summary Create a Relation
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRelation(
      fields?: Array<string>,
      meta?: string,
      inlineObject19?: InlineObject19,
      options?: any
    ): AxiosPromise<InlineResponse20025> {
      return localVarFp
        .createRelation(fields, meta, inlineObject19, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing relation.
     * @summary Delete a Relation
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRelation(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteRelation(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single relation by unique identifier.
     * @summary Retrieve a Relation
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelation(
      id: number,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20025> {
      return localVarFp
        .getRelation(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the relations.
     * @summary List Relations
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelations(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options?: any
    ): AxiosPromise<InlineResponse20024> {
      return localVarFp
        .getRelations(
          fields,
          limit,
          offset,
          meta,
          sort,
          filter,
          search,
          page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing relation
     * @summary Update a Relation
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRelation(
      id: number,
      fields?: Array<string>,
      meta?: string,
      inlineObject20?: InlineObject20,
      options?: any
    ): AxiosPromise<InlineResponse20025> {
      return localVarFp
        .updateRelation(id, fields, meta, inlineObject20, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RelationsApi - object-oriented interface
 * @export
 * @class RelationsApi
 * @extends {BaseAPI}
 */
export class RelationsApi extends BaseAPI {
  /**
   * Create a new relation.
   * @summary Create a Relation
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject19} [inlineObject19]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationsApi
   */
  public createRelation(
    fields?: Array<string>,
    meta?: string,
    inlineObject19?: InlineObject19,
    options?: AxiosRequestConfig
  ) {
    return RelationsApiFp(this.configuration)
      .createRelation(fields, meta, inlineObject19, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing relation.
   * @summary Delete a Relation
   * @param {number} id Index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationsApi
   */
  public deleteRelation(id: number, options?: AxiosRequestConfig) {
    return RelationsApiFp(this.configuration)
      .deleteRelation(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single relation by unique identifier.
   * @summary Retrieve a Relation
   * @param {number} id Index
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationsApi
   */
  public getRelation(
    id: number,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return RelationsApiFp(this.configuration)
      .getRelation(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the relations.
   * @summary List Relations
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationsApi
   */
  public getRelations(
    fields?: Array<string>,
    limit?: number,
    offset?: number,
    meta?: string,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return RelationsApiFp(this.configuration)
      .getRelations(
        fields,
        limit,
        offset,
        meta,
        sort,
        filter,
        search,
        page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing relation
   * @summary Update a Relation
   * @param {number} id Index
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject20} [inlineObject20]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationsApi
   */
  public updateRelation(
    id: number,
    fields?: Array<string>,
    meta?: string,
    inlineObject20?: InlineObject20,
    options?: AxiosRequestConfig
  ) {
    return RelationsApiFp(this.configuration)
      .updateRelation(id, fields, meta, inlineObject20, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RevisionsApi - axios parameter creator
 * @export
 */
export const RevisionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve a single revision by unique identifier.
     * @summary Retrieve a Revision
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevision: async (
      id: number,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getRevision', 'id', id)
      const localVarPath = `/revisions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the revisions.
     * @summary List Revisions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevisions: async (
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/revisions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RevisionsApi - functional programming interface
 * @export
 */
export const RevisionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RevisionsApiAxiosParamCreator(configuration)
  return {
    /**
     * Retrieve a single revision by unique identifier.
     * @summary Retrieve a Revision
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRevision(
      id: number,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20027>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRevision(
        id,
        fields,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the revisions.
     * @summary List Revisions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRevisions(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20026>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRevisions(
        fields,
        limit,
        offset,
        meta,
        sort,
        filter,
        search,
        page,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * RevisionsApi - factory interface
 * @export
 */
export const RevisionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RevisionsApiFp(configuration)
  return {
    /**
     * Retrieve a single revision by unique identifier.
     * @summary Retrieve a Revision
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevision(
      id: number,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20027> {
      return localVarFp
        .getRevision(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the revisions.
     * @summary List Revisions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevisions(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options?: any
    ): AxiosPromise<InlineResponse20026> {
      return localVarFp
        .getRevisions(
          fields,
          limit,
          offset,
          meta,
          sort,
          filter,
          search,
          page,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RevisionsApi - object-oriented interface
 * @export
 * @class RevisionsApi
 * @extends {BaseAPI}
 */
export class RevisionsApi extends BaseAPI {
  /**
   * Retrieve a single revision by unique identifier.
   * @summary Retrieve a Revision
   * @param {number} id Index
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RevisionsApi
   */
  public getRevision(
    id: number,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return RevisionsApiFp(this.configuration)
      .getRevision(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the revisions.
   * @summary List Revisions
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RevisionsApi
   */
  public getRevisions(
    fields?: Array<string>,
    limit?: number,
    offset?: number,
    meta?: string,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return RevisionsApiFp(this.configuration)
      .getRevisions(
        fields,
        limit,
        offset,
        meta,
        sort,
        filter,
        search,
        page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new role.
     * @summary Create a Role
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole: async (
      fields?: Array<string>,
      meta?: string,
      inlineObject21?: InlineObject21,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/roles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject21,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing role
     * @summary Delete a Role
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteRole', 'id', id)
      const localVarPath = `/roles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single role by unique identifier.
     * @summary Retrieve a Role
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole: async (
      id: string,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getRole', 'id', id)
      const localVarPath = `/roles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the roles.
     * @summary List Roles
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoles: async (
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/roles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing role
     * @summary Update a Role
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole: async (
      id: string,
      fields?: Array<string>,
      meta?: string,
      inlineObject22?: InlineObject22,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateRole', 'id', id)
      const localVarPath = `/roles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject22,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new role.
     * @summary Create a Role
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRole(
      fields?: Array<string>,
      meta?: string,
      inlineObject21?: InlineObject21,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20029>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(
        fields,
        meta,
        inlineObject21,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing role
     * @summary Delete a Role
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRole(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single role by unique identifier.
     * @summary Retrieve a Role
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRole(
      id: string,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20029>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(
        id,
        fields,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the roles.
     * @summary List Roles
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoles(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20028>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRoles(
        fields,
        limit,
        offset,
        meta,
        sort,
        filter,
        search,
        page,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing role
     * @summary Update a Role
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRole(
      id: string,
      fields?: Array<string>,
      meta?: string,
      inlineObject22?: InlineObject22,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20029>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(
        id,
        fields,
        meta,
        inlineObject22,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RolesApiFp(configuration)
  return {
    /**
     * Create a new role.
     * @summary Create a Role
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole(
      fields?: Array<string>,
      meta?: string,
      inlineObject21?: InlineObject21,
      options?: any
    ): AxiosPromise<InlineResponse20029> {
      return localVarFp
        .createRole(fields, meta, inlineObject21, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing role
     * @summary Delete a Role
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteRole(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single role by unique identifier.
     * @summary Retrieve a Role
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(
      id: string,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20029> {
      return localVarFp
        .getRole(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the roles.
     * @summary List Roles
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoles(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      page?: number,
      options?: any
    ): AxiosPromise<InlineResponse20028> {
      return localVarFp
        .getRoles(
          fields,
          limit,
          offset,
          meta,
          sort,
          filter,
          search,
          page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing role
     * @summary Update a Role
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(
      id: string,
      fields?: Array<string>,
      meta?: string,
      inlineObject22?: InlineObject22,
      options?: any
    ): AxiosPromise<InlineResponse20029> {
      return localVarFp
        .updateRole(id, fields, meta, inlineObject22, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
  /**
   * Create a new role.
   * @summary Create a Role
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject21} [inlineObject21]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public createRole(
    fields?: Array<string>,
    meta?: string,
    inlineObject21?: InlineObject21,
    options?: AxiosRequestConfig
  ) {
    return RolesApiFp(this.configuration)
      .createRole(fields, meta, inlineObject21, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing role
   * @summary Delete a Role
   * @param {string} id Unique identifier for the object.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public deleteRole(id: string, options?: AxiosRequestConfig) {
    return RolesApiFp(this.configuration)
      .deleteRole(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single role by unique identifier.
   * @summary Retrieve a Role
   * @param {string} id Unique identifier for the object.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public getRole(
    id: string,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return RolesApiFp(this.configuration)
      .getRole(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the roles.
   * @summary List Roles
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public getRoles(
    fields?: Array<string>,
    limit?: number,
    offset?: number,
    meta?: string,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return RolesApiFp(this.configuration)
      .getRoles(
        fields,
        limit,
        offset,
        meta,
        sort,
        filter,
        search,
        page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing role
   * @summary Update a Role
   * @param {string} id Unique identifier for the object.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject22} [inlineObject22]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  public updateRole(
    id: string,
    fields?: Array<string>,
    meta?: string,
    inlineObject22?: InlineObject22,
    options?: AxiosRequestConfig
  ) {
    return RolesApiFp(this.configuration)
      .updateRole(id, fields, meta, inlineObject22, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Ping, pong. Ping.. pong.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/server/ping`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Perform a system status check and return the options.
     * @summary System Info
     * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    serverInfo: async (
      superAdminToken: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'superAdminToken' is not null or undefined
      assertParamExists('serverInfo', 'superAdminToken', superAdminToken)
      const localVarPath = `/server/info`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (superAdminToken !== undefined) {
        localVarQueryParameter['super_admin_token'] = superAdminToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
  return {
    /**
     * Ping, pong. Ping.. pong.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Perform a system status check and return the options.
     * @summary System Info
     * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async serverInfo(
      superAdminToken: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2005>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.serverInfo(
        superAdminToken,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ServerApiFp(configuration)
  return {
    /**
     * Ping, pong. Ping.. pong.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<string> {
      return localVarFp
        .ping(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Perform a system status check and return the options.
     * @summary System Info
     * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    serverInfo(
      superAdminToken: number,
      options?: any
    ): AxiosPromise<InlineResponse2005> {
      return localVarFp
        .serverInfo(superAdminToken, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
  /**
   * Ping, pong. Ping.. pong.
   * @summary Ping
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public ping(options?: AxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .ping(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Perform a system status check and return the options.
   * @summary System Info
   * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public serverInfo(superAdminToken: number, options?: AxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .serverInfo(superAdminToken, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * List the settings.
     * @summary Retrieve Settings
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings: async (
      limit?: number,
      offset?: number,
      meta?: string,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the settings
     * @summary Update Settings
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSetting: async (
      body?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
  return {
    /**
     * List the settings.
     * @summary Retrieve Settings
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSettings(
      limit?: number,
      offset?: number,
      meta?: string,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20030>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(
        limit,
        offset,
        meta,
        page,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update the settings
     * @summary Update Settings
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSetting(
      body?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20030>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSetting(
        body,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SettingsApiFp(configuration)
  return {
    /**
     * List the settings.
     * @summary Retrieve Settings
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings(
      limit?: number,
      offset?: number,
      meta?: string,
      page?: number,
      options?: any
    ): AxiosPromise<InlineResponse20030> {
      return localVarFp
        .getSettings(limit, offset, meta, page, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the settings
     * @summary Update Settings
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSetting(
      body?: object,
      options?: any
    ): AxiosPromise<InlineResponse20030> {
      return localVarFp
        .updateSetting(body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
  /**
   * List the settings.
   * @summary Retrieve Settings
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {string} [meta] What metadata to return in the response.
   * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public getSettings(
    limit?: number,
    offset?: number,
    meta?: string,
    page?: number,
    options?: AxiosRequestConfig
  ) {
    return SettingsApiFp(this.configuration)
      .getSettings(limit, offset, meta, page, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the settings
   * @summary Update Settings
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public updateSetting(body?: object, options?: AxiosRequestConfig) {
    return SettingsApiFp(this.configuration)
      .updateSetting(body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Accepts and enables an invited user using a JWT invitation token.
     * @summary Accept User Invite
     * @param {InlineObject24} inlineObject24
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInvite: async (
      inlineObject24: InlineObject24,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject24' is not null or undefined
      assertParamExists('acceptInvite', 'inlineObject24', inlineObject24)
      const localVarPath = `/users/invite/accept`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject24,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new user.
     * @summary Create a User
     * @param {string} [meta] What metadata to return in the response.
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (
      meta?: string,
      users?: Users,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        users,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing user
     * @summary Delete a User
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteUser', 'id', id)
      const localVarPath = `/users/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the currently authenticated user.
     * @summary Retrieve Current User
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMe: async (
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/me`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single user by unique identifier.
     * @summary Retrieve a User
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (
      id: string,
      fields?: Array<string>,
      meta?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getUser', 'id', id)
      const localVarPath = `/users/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List the users.
     * @summary List Users
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv)
      }

      if (filter) {
        localVarQueryParameter['filter'] = filter
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account.
     * @summary Invite User(s)
     * @param {InlineObject23} [inlineObject23]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invite: async (
      inlineObject23?: InlineObject23,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/invite`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject23,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Disables two-factor authentication for the currently authenticated user.
     * @summary Disable 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meTfaDisable: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/me/tfa/disable`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Enables two-factor authentication for the currently authenticated user.
     * @summary Enable 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meTfaEnable: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/me/tfa/enable`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used.
     * @summary Update Last Page
     * @param {InlineObject25} [inlineObject25]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLastUsedPageMe: async (
      inlineObject25?: InlineObject25,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/me/track/page`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject25,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the currently authenticated user.
     * @summary Update Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMe: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/me`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing user
     * @summary Update a User
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      id: string,
      fields?: Array<string>,
      meta?: string,
      users?: Users,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateUser', 'id', id)
      const localVarPath = `/users/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        users,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
  return {
    /**
     * Accepts and enables an invited user using a JWT invitation token.
     * @summary Accept User Invite
     * @param {InlineObject24} inlineObject24
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async acceptInvite(
      inlineObject24: InlineObject24,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20032>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(
        inlineObject24,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Create a new user.
     * @summary Create a User
     * @param {string} [meta] What metadata to return in the response.
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      meta?: string,
      users?: Users,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20032>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        meta,
        users,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing user
     * @summary Delete a User
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve the currently authenticated user.
     * @summary Retrieve Current User
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMe(
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20032>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(
        fields,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single user by unique identifier.
     * @summary Retrieve a User
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      id: string,
      fields?: Array<string>,
      meta?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20032>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(
        id,
        fields,
        meta,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * List the users.
     * @summary List Users
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20031>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        fields,
        limit,
        offset,
        meta,
        sort,
        filter,
        search,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account.
     * @summary Invite User(s)
     * @param {InlineObject23} [inlineObject23]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async invite(
      inlineObject23?: InlineObject23,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20032>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.invite(
        inlineObject23,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Disables two-factor authentication for the currently authenticated user.
     * @summary Disable 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async meTfaDisable(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.meTfaDisable(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Enables two-factor authentication for the currently authenticated user.
     * @summary Enable 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async meTfaEnable(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.meTfaEnable(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used.
     * @summary Update Last Page
     * @param {InlineObject25} [inlineObject25]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLastUsedPageMe(
      inlineObject25?: InlineObject25,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateLastUsedPageMe(
          inlineObject25,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update the currently authenticated user.
     * @summary Update Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMe(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20032>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateMe(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing user
     * @summary Update a User
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      id: string,
      fields?: Array<string>,
      meta?: string,
      users?: Users,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2005>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        id,
        fields,
        meta,
        users,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration)
  return {
    /**
     * Accepts and enables an invited user using a JWT invitation token.
     * @summary Accept User Invite
     * @param {InlineObject24} inlineObject24
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInvite(
      inlineObject24: InlineObject24,
      options?: any
    ): AxiosPromise<InlineResponse20032> {
      return localVarFp
        .acceptInvite(inlineObject24, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new user.
     * @summary Create a User
     * @param {string} [meta] What metadata to return in the response.
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      meta?: string,
      users?: Users,
      options?: any
    ): AxiosPromise<InlineResponse20032> {
      return localVarFp
        .createUser(meta, users, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing user
     * @summary Delete a User
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteUser(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the currently authenticated user.
     * @summary Retrieve Current User
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMe(
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20032> {
      return localVarFp
        .getMe(fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single user by unique identifier.
     * @summary Retrieve a User
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(
      id: string,
      fields?: Array<string>,
      meta?: string,
      options?: any
    ): AxiosPromise<InlineResponse20032> {
      return localVarFp
        .getUser(id, fields, meta, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List the users.
     * @summary List Users
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(
      fields?: Array<string>,
      limit?: number,
      offset?: number,
      meta?: string,
      sort?: Array<string>,
      filter?: Array<string>,
      search?: string,
      options?: any
    ): AxiosPromise<InlineResponse20031> {
      return localVarFp
        .getUsers(fields, limit, offset, meta, sort, filter, search, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account.
     * @summary Invite User(s)
     * @param {InlineObject23} [inlineObject23]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invite(
      inlineObject23?: InlineObject23,
      options?: any
    ): AxiosPromise<InlineResponse20032> {
      return localVarFp
        .invite(inlineObject23, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Disables two-factor authentication for the currently authenticated user.
     * @summary Disable 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meTfaDisable(options?: any): AxiosPromise<void> {
      return localVarFp
        .meTfaDisable(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Enables two-factor authentication for the currently authenticated user.
     * @summary Enable 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meTfaEnable(options?: any): AxiosPromise<void> {
      return localVarFp
        .meTfaEnable(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used.
     * @summary Update Last Page
     * @param {InlineObject25} [inlineObject25]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLastUsedPageMe(
      inlineObject25?: InlineObject25,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateLastUsedPageMe(inlineObject25, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update the currently authenticated user.
     * @summary Update Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMe(options?: any): AxiosPromise<InlineResponse20032> {
      return localVarFp
        .updateMe(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing user
     * @summary Update a User
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      id: string,
      fields?: Array<string>,
      meta?: string,
      users?: Users,
      options?: any
    ): AxiosPromise<InlineResponse2005> {
      return localVarFp
        .updateUser(id, fields, meta, users, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Accepts and enables an invited user using a JWT invitation token.
   * @summary Accept User Invite
   * @param {InlineObject24} inlineObject24
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public acceptInvite(
    inlineObject24: InlineObject24,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .acceptInvite(inlineObject24, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new user.
   * @summary Create a User
   * @param {string} [meta] What metadata to return in the response.
   * @param {Users} [users]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createUser(
    meta?: string,
    users?: Users,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .createUser(meta, users, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing user
   * @summary Delete a User
   * @param {string} id Unique identifier for the object.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUser(id: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .deleteUser(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the currently authenticated user.
   * @summary Retrieve Current User
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getMe(
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getMe(fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single user by unique identifier.
   * @summary Retrieve a User
   * @param {string} id Unique identifier for the object.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUser(
    id: string,
    fields?: Array<string>,
    meta?: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getUser(id, fields, meta, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List the users.
   * @summary List Users
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {number} [limit] A limit on the number of objects that are returned.
   * @param {number} [offset] How many items to skip when fetching data.
   * @param {string} [meta] What metadata to return in the response.
   * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly.
   * @param {Array<string>} [filter] Select items in collection by given conditions.
   * @param {string} [search] Filter by items that contain the given search query in one of their fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsers(
    fields?: Array<string>,
    limit?: number,
    offset?: number,
    meta?: string,
    sort?: Array<string>,
    filter?: Array<string>,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getUsers(fields, limit, offset, meta, sort, filter, search, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account.
   * @summary Invite User(s)
   * @param {InlineObject23} [inlineObject23]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public invite(inlineObject23?: InlineObject23, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .invite(inlineObject23, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Disables two-factor authentication for the currently authenticated user.
   * @summary Disable 2FA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public meTfaDisable(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .meTfaDisable(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Enables two-factor authentication for the currently authenticated user.
   * @summary Enable 2FA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public meTfaEnable(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .meTfaEnable(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used.
   * @summary Update Last Page
   * @param {InlineObject25} [inlineObject25]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateLastUsedPageMe(
    inlineObject25?: InlineObject25,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updateLastUsedPageMe(inlineObject25, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the currently authenticated user.
   * @summary Update Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateMe(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .updateMe(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing user
   * @summary Update a User
   * @param {string} id Unique identifier for the object.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {Users} [users]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateUser(
    id: string,
    fields?: Array<string>,
    meta?: string,
    users?: Users,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updateUser(id, fields, meta, users, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UtilitiesApi - axios parameter creator
 * @export
 */
export const UtilitiesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns a random string of given length.
     * @summary Get a Random String
     * @param {number} [length] Length of the random string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    random: async (
      length?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/utils/random/string`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (length !== undefined) {
        localVarQueryParameter['length'] = length
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Re-sort items in collection based on start and to value of item
     * @summary Sort Items
     * @param {string} collection Collection identifier
     * @param {unknown} [uNKNOWNBASETYPE]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sort: async (
      collection: string,
      uNKNOWNBASETYPE?: unknown,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'collection' is not null or undefined
      assertParamExists('sort', 'collection', collection)
      const localVarPath = `/utils/sort/{collection}`.replace(
        `{${'collection'}}`,
        encodeURIComponent(String(collection))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        uNKNOWNBASETYPE,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UtilitiesApi - functional programming interface
 * @export
 */
export const UtilitiesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UtilitiesApiAxiosParamCreator(configuration)
  return {
    /**
     * Returns a random string of given length.
     * @summary Get a Random String
     * @param {number} [length] Length of the random string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async random(
      length?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2006>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.random(
        length,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Re-sort items in collection based on start and to value of item
     * @summary Sort Items
     * @param {string} collection Collection identifier
     * @param {unknown} [uNKNOWNBASETYPE]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sort(
      collection: string,
      uNKNOWNBASETYPE?: unknown,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sort(
        collection,
        uNKNOWNBASETYPE,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * UtilitiesApi - factory interface
 * @export
 */
export const UtilitiesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UtilitiesApiFp(configuration)
  return {
    /**
     * Returns a random string of given length.
     * @summary Get a Random String
     * @param {number} [length] Length of the random string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    random(length?: number, options?: any): AxiosPromise<InlineResponse2006> {
      return localVarFp
        .random(length, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Re-sort items in collection based on start and to value of item
     * @summary Sort Items
     * @param {string} collection Collection identifier
     * @param {unknown} [uNKNOWNBASETYPE]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sort(
      collection: string,
      uNKNOWNBASETYPE?: unknown,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .sort(collection, uNKNOWNBASETYPE, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UtilitiesApi - object-oriented interface
 * @export
 * @class UtilitiesApi
 * @extends {BaseAPI}
 */
export class UtilitiesApi extends BaseAPI {
  /**
   * Returns a random string of given length.
   * @summary Get a Random String
   * @param {number} [length] Length of the random string.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilitiesApi
   */
  public random(length?: number, options?: AxiosRequestConfig) {
    return UtilitiesApiFp(this.configuration)
      .random(length, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Re-sort items in collection based on start and to value of item
   * @summary Sort Items
   * @param {string} collection Collection identifier
   * @param {unknown} [uNKNOWNBASETYPE]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilitiesApi
   */
  public sort(
    collection: string,
    uNKNOWNBASETYPE?: unknown,
    options?: AxiosRequestConfig
  ) {
    return UtilitiesApiFp(this.configuration)
      .sort(collection, uNKNOWNBASETYPE, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a new webhook.
     * @summary Create a Webhook
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject26} [inlineObject26]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook: async (
      fields?: Array<string>,
      meta?: string,
      inlineObject26?: InlineObject26,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/webhooks`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject26,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete an existing webhook
     * @summary Delete a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteWebhook', 'id', id)
      const localVarPath = `/webhooks/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve a single webhook by unique identifier.
     * @summary Retrieve a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getWebhook', 'id', id)
      const localVarPath = `/webhooks/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all webhooks.
     * @summary List Webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooks: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/webhooks`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update an existing webhook
     * @summary Update a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject27} [inlineObject27]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook: async (
      id: string,
      fields?: Array<string>,
      meta?: string,
      inlineObject27?: InlineObject27,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateWebhook', 'id', id)
      const localVarPath = `/webhooks/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (fields) {
        localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv)
      }

      if (meta !== undefined) {
        localVarQueryParameter['meta'] = meta
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject27,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new webhook.
     * @summary Create a Webhook
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject26} [inlineObject26]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWebhook(
      fields?: Array<string>,
      meta?: string,
      inlineObject26?: InlineObject26,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20029>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(
        fields,
        meta,
        inlineObject26,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete an existing webhook
     * @summary Delete a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWebhook(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Retrieve a single webhook by unique identifier.
     * @summary Retrieve a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhook(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20033>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get all webhooks.
     * @summary List Webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhooks(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20033>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Update an existing webhook
     * @summary Update a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject27} [inlineObject27]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWebhook(
      id: string,
      fields?: Array<string>,
      meta?: string,
      inlineObject27?: InlineObject27,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20029>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(
        id,
        fields,
        meta,
        inlineObject27,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WebhooksApiFp(configuration)
  return {
    /**
     * Create a new webhook.
     * @summary Create a Webhook
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject26} [inlineObject26]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(
      fields?: Array<string>,
      meta?: string,
      inlineObject26?: InlineObject26,
      options?: any
    ): AxiosPromise<InlineResponse20029> {
      return localVarFp
        .createWebhook(fields, meta, inlineObject26, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete an existing webhook
     * @summary Delete a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteWebhook(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieve a single webhook by unique identifier.
     * @summary Retrieve a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(id: string, options?: any): AxiosPromise<InlineResponse20033> {
      return localVarFp
        .getWebhook(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get all webhooks.
     * @summary List Webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooks(options?: any): AxiosPromise<InlineResponse20033> {
      return localVarFp
        .getWebhooks(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update an existing webhook
     * @summary Update a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {InlineObject27} [inlineObject27]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook(
      id: string,
      fields?: Array<string>,
      meta?: string,
      inlineObject27?: InlineObject27,
      options?: any
    ): AxiosPromise<InlineResponse20029> {
      return localVarFp
        .updateWebhook(id, fields, meta, inlineObject27, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
  /**
   * Create a new webhook.
   * @summary Create a Webhook
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject26} [inlineObject26]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public createWebhook(
    fields?: Array<string>,
    meta?: string,
    inlineObject26?: InlineObject26,
    options?: AxiosRequestConfig
  ) {
    return WebhooksApiFp(this.configuration)
      .createWebhook(fields, meta, inlineObject26, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete an existing webhook
   * @summary Delete a Webhook
   * @param {string} id Unique identifier for the object.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public deleteWebhook(id: string, options?: AxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .deleteWebhook(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve a single webhook by unique identifier.
   * @summary Retrieve a Webhook
   * @param {string} id Unique identifier for the object.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public getWebhook(id: string, options?: AxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .getWebhook(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all webhooks.
   * @summary List Webhooks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public getWebhooks(options?: AxiosRequestConfig) {
    return WebhooksApiFp(this.configuration)
      .getWebhooks(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update an existing webhook
   * @summary Update a Webhook
   * @param {string} id Unique identifier for the object.
   * @param {Array<string>} [fields] Control what fields are being returned in the object.
   * @param {string} [meta] What metadata to return in the response.
   * @param {InlineObject27} [inlineObject27]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public updateWebhook(
    id: string,
    fields?: Array<string>,
    meta?: string,
    inlineObject27?: InlineObject27,
    options?: AxiosRequestConfig
  ) {
    return WebhooksApiFp(this.configuration)
      .updateWebhook(id, fields, meta, inlineObject27, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
